// YouTube transcript tools - Direct access via InnerTube API - Mastra format
import { z } from 'zod';
import { Logger } from '../utils/logger';
import { requestUrl } from 'obsidian';
import type { MastraTool } from './mastra-tool-types';
import { createMastraTool } from './tool-converter';

interface CaptionTrack {
  baseUrl: string;
  name?: {
    simpleText?: string;
    runs?: Array<{ text: string }>;
  };
  languageCode: string;
  kind?: string;
}

interface TranscriptSegment {
  text: string;
  start?: number;
  duration?: number;
}

/**
 * Extract video ID from various YouTube URL formats
 */
function extractVideoId(url: string | undefined): string | null {
  if (!url || typeof url !== 'string' || url.trim() === '') {
    return null;
  }
  
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/shorts\/)([a-zA-Z0-9_-]{11})(?:[?&#]|$)/,
    /^([a-zA-Z0-9_-]{11})$/ // Direct video ID
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) {
      return match[1];
    }
  }

  return null;
}

/**
 * Parse XML subtitle format to extract text segments
 */
function parseSubtitleXml(xmlContent: string): TranscriptSegment[] {
  const segments: TranscriptSegment[] = [];
  
  const textPattern = /<text[^>]*start="([^"]*)"[^>]*dur="([^"]*)"[^>]*>(.*?)<\/text>/g;
  let match;

  while ((match = textPattern.exec(xmlContent)) !== null) {
    const start = parseFloat(match[1]);
    const duration = parseFloat(match[2]);
    let text = match[3];

    text = text
      .replace(/&amp;/g, '&')
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'")
      .replace(/<[^>]*>/g, '')
      .trim();

    if (text) {
      segments.push({ text, start, duration });
    }
  }

  return segments;
}

/**
 * Format time in seconds to HH:MM:SS format
 */
function formatTimestamp(seconds: number): string {
  const hrs = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  
  if (hrs > 0) {
    return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  }
  return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

/**
 * Get YouTube transcript using InnerTube API
 */
export const getYouTubeTranscriptTool: MastraTool = createMastraTool({
  category: 'search-web',
  id: 'get_youtube_transcript',
  description: 'Get YouTube video transcript/subtitles directly from YouTube InnerTube API. Supports multiple languages, auto-generated and manual captions. Returns full transcript without third-party API dependencies.',
  
  inputSchema: z.object({
    url: z.string()
      .describe('YouTube video URL or video ID. Supports: youtube.com/watch?v=ID, youtu.be/ID, youtu.be/ID?si=xxx, youtube.com/shorts/ID, or direct VIDEO_ID'),
    
    language: z.string()
      .optional()
      .default('auto')
      .describe('Preferred language code (e.g., "zh", "en", "ja"). If not specified, will prioritize Chinese > English > first available.'),
    
    format: z.enum(['text', 'timestamped', 'json'])
      .optional()
      .default('text')
      .describe('Output format: "text" (plain text), "timestamped" (with timestamps), "json" (structured data)'),
    
    includeAutoGenerated: z.boolean()
      .optional()
      .default(true)
      .describe('Whether to include auto-generated captions. Default true.')
  }),
  
  outputSchema: z.object({
    success: z.boolean(),
    videoId: z.string().optional(),
    videoUrl: z.string().optional(),
    language: z.string().optional(),
    languageCode: z.string().optional(),
    isAutoGenerated: z.boolean().optional(),
    format: z.string().optional(),
    segmentCount: z.number().optional(),
    totalDuration: z.number().optional(),
    totalDurationFormatted: z.string().optional(),
    characterCount: z.number().optional(),
    transcript: z.union([z.string(), z.array(z.any())]).optional(),
    availableCaptions: z.array(z.object({
      language: z.string(),
      languageCode: z.string(),
      isAutoGenerated: z.boolean()
    })).optional(),
    error: z.string().optional(),
    url: z.string().optional()
  }).describe('YouTube video transcript and metadata'),
  
  execute: async ({ context }) => {
    try {
      if (!context || !context.url) {
        Logger.error('‚ùå Error fetching YouTube transcript: URL parameter is missing');
        throw new Error('URL parameter is required. Please provide a YouTube video URL or video ID.');
      }
      
      const videoId = extractVideoId(context.url);
      if (!videoId) {
        Logger.error('‚ùå Error fetching YouTube transcript: Invalid URL format');
        throw new Error('Invalid YouTube URL or video ID. Please provide a valid YouTube video URL.');
      }

      Logger.debug(`üìπ Fetching transcript for video ID: ${videoId}`);

      const format = context.format || 'text';
      const preferredLanguage = context.language || 'auto';
      const includeAutoGenerated = context.includeAutoGenerated !== false;

      Logger.debug('üîç Fetching video page to extract API key...');
      
      const videoPageUrl = `https://www.youtube.com/watch?v=${videoId}`;
      const pageResponse = await requestUrl({
        url: videoPageUrl,
        method: 'GET',
        headers: {
          'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
          'Accept-Language': 'en-US,en;q=0.9'
        },
        throw: false
      });

      if (pageResponse.status !== 200) {
        throw new Error(`Failed to fetch video page: HTTP ${pageResponse.status}`);
      }

      const html = pageResponse.text;
      const apiKeyMatch = html.match(/"INNERTUBE_API_KEY":\s*"([a-zA-Z0-9_-]+)"/);
      
      if (!apiKeyMatch) {
        throw new Error('Could not extract YouTube API key from page. Video may be unavailable.');
      }

      const apiKey = apiKeyMatch[1];
      Logger.debug('‚úì Found YouTube API key');

      Logger.debug('üì° Calling YouTube InnerTube API...');
      
      const innertubeUrl = `https://www.youtube.com/youtubei/v1/player?key=${apiKey}`;
      const innertubeResponse = await requestUrl({
        url: innertubeUrl,
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
        },
        body: JSON.stringify({
          context: {
            client: {
              clientName: 'WEB',
              clientVersion: '2.20231219.04.00'
            }
          },
          videoId: videoId
        }),
        throw: false
      });

      if (innertubeResponse.status !== 200) {
        throw new Error(`InnerTube API error: HTTP ${innertubeResponse.status}`);
      }

      const innertubeData = innertubeResponse.json;

      const playabilityStatus = innertubeData.playabilityStatus?.status;
      if (playabilityStatus !== 'OK') {
        const reason = innertubeData.playabilityStatus?.reason || 'Video is not playable';
        throw new Error(`Video unavailable: ${reason}`);
      }

      Logger.debug('‚úì Video is playable');

      const captionsData = innertubeData.captions?.playerCaptionsTracklistRenderer;
      
      if (!captionsData || !captionsData.captionTracks || captionsData.captionTracks.length === 0) {
        throw new Error('This video does not have any captions/subtitles available.');
      }

      const captionTracks: CaptionTrack[] = captionsData.captionTracks;
      Logger.debug(`‚úì Found ${captionTracks.length} caption track(s)`);

      const availableTracks = includeAutoGenerated 
        ? captionTracks 
        : captionTracks.filter(track => track.kind !== 'asr');

      if (availableTracks.length === 0) {
        throw new Error('No manual captions available (auto-generated captions excluded by settings).');
      }

      let selectedTrack: CaptionTrack | undefined;

      if (preferredLanguage !== 'auto') {
        selectedTrack = availableTracks.find(track => 
          track.languageCode === preferredLanguage || 
          track.languageCode.startsWith(preferredLanguage)
        );
      }

      if (!selectedTrack) {
        selectedTrack = availableTracks.find(track => 
          track.languageCode.startsWith('zh')
        ) || availableTracks.find(track => 
          track.languageCode === 'en' || track.languageCode.startsWith('en')
        ) || availableTracks[0];
      }

      if (!selectedTrack) {
        throw new Error('Could not select a caption track.');
      }

      const trackName = selectedTrack.name?.simpleText || 
                       selectedTrack.name?.runs?.[0]?.text || 
                       selectedTrack.languageCode;
      const isAutoGenerated = selectedTrack.kind === 'asr';
      
      Logger.debug(`‚úÖ Selected caption: ${trackName} [${selectedTrack.languageCode}] ${isAutoGenerated ? '(auto-generated)' : '(manual)'}`);

      let captionUrl = selectedTrack.baseUrl;
      captionUrl = captionUrl.replace(/&fmt=srv3/g, '');
      
      if (captionUrl.includes('&exp=xpe')) {
        Logger.warn('‚ö†Ô∏è This video requires po_token authentication');
        throw new Error('This video requires additional authentication (po_token). Cannot fetch captions directly.');
      }

      Logger.debug('‚è≥ Downloading caption data...');
      
      const captionResponse = await requestUrl({
        url: captionUrl,
        method: 'GET',
        headers: {
          'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
        },
        throw: false
      });

      if (captionResponse.status !== 200) {
        throw new Error(`Failed to fetch caption content: HTTP ${captionResponse.status}`);
      }

      const captionXml = captionResponse.text;

      Logger.debug('üìù Parsing caption content...');
      const segments = parseSubtitleXml(captionXml);

      if (segments.length === 0) {
        throw new Error('Caption content is empty or could not be parsed.');
      }

      Logger.debug(`‚úì Parsed ${segments.length} caption segment(s)`);

      let formattedTranscript: string | TranscriptSegment[];

      switch (format) {
        case 'text':
          formattedTranscript = segments.map(s => s.text).join(' ');
          break;

        case 'timestamped':
          formattedTranscript = segments
            .map(s => `[${formatTimestamp(s.start || 0)}] ${s.text}`)
            .join('\n');
          break;

        case 'json':
          formattedTranscript = segments;
          break;

        default:
          formattedTranscript = segments.map(s => s.text).join(' ');
      }

      const totalDuration = segments.length > 0 
        ? Math.max(...segments.map(s => (s.start || 0) + (s.duration || 0)))
        : 0;

      const result = {
        success: true,
        videoId,
        videoUrl: `https://www.youtube.com/watch?v=${videoId}`,
        language: trackName,
        languageCode: selectedTrack.languageCode,
        isAutoGenerated,
        format,
        segmentCount: segments.length,
        totalDuration: Math.round(totalDuration),
        totalDurationFormatted: formatTimestamp(totalDuration),
        characterCount: segments.reduce((sum, s) => sum + s.text.length, 0),
        transcript: formattedTranscript,
        availableCaptions: captionTracks.map(track => ({
          language: track.name?.simpleText || track.name?.runs?.[0]?.text || track.languageCode,
          languageCode: track.languageCode,
          isAutoGenerated: track.kind === 'asr'
        }))
      };

      Logger.debug('‚úÖ Transcript fetched successfully');
      Logger.debug(`üìä Stats: ${result.segmentCount} segments, ${result.characterCount} characters, ${result.totalDurationFormatted} duration`);

      return result;

    } catch (error) {
      Logger.error('‚ùå Error fetching YouTube transcript:', error);
      throw new Error(error instanceof Error ? error.message : 'Unknown error occurred');
    }
  }
});
