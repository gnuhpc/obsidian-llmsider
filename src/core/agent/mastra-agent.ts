/**
 * Mastra Agent Integration for LLMSider
 * 
 * This module provides a wrapper around mastra's Agent class to integrate
 * with LLMSider's existing architecture while leveraging mastra's powerful
 * agent capabilities including:
 * - Multi-step planning and execution
 * - Tool orchestration
 * - Memory management
 * - Streaming responses
 */

import { z } from 'zod';
import { Logger } from '../../utils/logger';
import LLMSiderPlugin from '../../main';
import { ChatMessage } from '../../types';
import { UnifiedTool } from '../../tools/unified-tool-manager';
import { I18nManager } from '../../i18n/i18n-manager';
import { convertToolsToMastraFormat } from './tool-converter';
import { MastraStreamAdapter } from './stream-adapter';
import { StreamingIndicatorManager } from '../../processors/helpers/streaming-indicator-manager';
import { PromptBuilder } from '../../processors/prompts/prompt-builder';
import { ErrorRenderer } from '../../ui/error-renderer';
import { TokenManager } from '../../utils/token-manager';
import { Agent } from '@mastra/core/agent';
import { Memory } from '@mastra/memory';
import { createWorkflow, createStep } from '@mastra/core';
import { MemoryManager, MemoryConfig } from './memory-manager';
import { ContentBatchProcessor } from './content-batch-processor';

/**
 * Configuration for creating a MastraAgent instance
 */
export interface MastraAgentConfig {
	/** Plugin instance for accessing LLMSider services */
	plugin: LLMSiderPlugin;
	/** Internationalization manager */
	i18n: I18nManager;
	/** Streaming indicator manager for UI updates */
	streamingManager?: StreamingIndicatorManager;
	/** Context manager for accessing referenced files */
	contextManager?: any;
	/** Agent ID */
	id?: string;
	/** Agent name */
	name: string;
	/** Agent instructions/system prompt */
	instructions: string;
	/** Available tools for the agent */
	tools?: Record<string, UnifiedTool>;
	/** Maximum retry attempts for failed operations */
	maxRetries?: number;
	/** Enable debug logging */
	debug?: boolean;
	/** Memory manager instance for shared memory configuration */
	memoryManager?: MemoryManager;
	/** Memory configuration (if memoryManager not provided) */
	memoryConfig?: MemoryConfig;
	/** Thread ID for memory scoping (e.g., chat session ID) */
	threadId?: string;
	/** Resource ID for memory scoping (e.g., user/vault ID) */
	resourceId?: string;
}

/**
 * Options for executing agent operations
 */
export interface AgentExecuteOptions {
	/** User messages to process */
	messages: ChatMessage[];
	/** Maximum steps for multi-step execution */
	maxSteps?: number;
	/** Abort controller for cancellation */
	abortController?: AbortController;
	/** Callback for streaming updates */
	onStream?: (chunk: string) => void;
	/** Callback for plan generation */
	onPlanGenerated?: (plan: AgentPlan) => void;
	/** Callback for step execution */
	onStepExecuted?: (step: AgentStep) => void;
	/** Graph execution: called when a dynamic step is about to start */
	onGraphStepStart?: (stepNumber: number, step: AgentStep, executedSteps: AgentStep[]) => void;
	/** Graph execution: called when a dynamic step completes */
	onGraphStepComplete?: (stepNumber: number, step: AgentStep) => void;
	/** Graph execution: called to update overall visualization */
	onGraphVisualizationUpdate?: (allSteps: AgentStep[], currentStepIndex: number) => void;
}

/**
 * Represents a plan generated by the agent
 */
export interface AgentPlan {
	/** Unique identifier for the plan */
	id: string;
	/** Plan steps */
	steps: AgentStep[];
	/** Estimated tokens for execution */
	estimatedTokens?: number;
}

/**
 * Tool call information for tracking request/response/errors
 */
export interface AgentToolCall {
	/** Tool call ID */
	id: string;
	/** Tool name */
	toolName: string;
	/** Tool type */
	toolType: 'mcp' | 'builtin' | 'api';
	/** Tool input parameters (REQUEST) */
	parameters: Record<string, unknown>;
	/** Tool output response (RESPONSE) */
	response?: Record<string, unknown> | string;
	/** Error information if failed (ERROR) */
	error?: string;
	/** Timestamp */
	timestamp?: string;
	/** Start time */
	startTime?: string;
	/** Duration in milliseconds */
	duration?: number;
	/** Reason for this tool call */
	reason?: string;
}

/**
 * Represents a single step in an agent plan
 */
export interface AgentStep {
	/** Step ID */
	id: string;
	/** Tool to execute */
	tool: string;
	/** Tool input parameters */
	input: Record<string, unknown>;
	/** Reason for this step */
	reason: string;
	/** Step status */
	status: 'pending' | 'executing' | 'completed' | 'failed' | 'cancelled' | 'skipped' | 'in-progress';
	/** Execution result */
	result?: unknown;
	/** Error information if failed */
	error?: string;
	/** Tool calls with detailed request/response/error information */
	toolCalls?: AgentToolCall[];
	/** Dependencies: IDs of steps that must complete before this step can execute (for DAG mode) */
	dependencies?: string[];
	/** Output schema for data passing validation */
	outputSchema?: {
		type: string;
		properties?: Record<string, unknown>;
		items?: unknown;
		description?: string;
	};
}

/**
 * MastraAgent - Wraps mastra's Agent class to integrate with LLMSider
 * 
 * This class bridges mastra's powerful agent capabilities with LLMSider's
 * existing architecture, providing a seamless integration while maintaining
 * compatibility with existing code.
 */
export class MastraAgent {
	private plugin: LLMSiderPlugin;
	private i18n: I18nManager;
	private agent: any | null = null;  // Mastra Agent instance
	private debug: boolean;
	private provider: any | null = null;
	private tools: Record<string, UnifiedTool> = {};
	private instructions: string = '';
	private streamingManager: StreamingIndicatorManager | null = null;
	private streamAdapter: MastraStreamAdapter | null = null;
	private agentConfig: any = null;
	private currentPlan: AgentPlan | null = null;  // Store current plan for step resolution
	private promptBuilder: PromptBuilder;  // Use PromptBuilder for consistent prompts
	private originalUserQuery: string = '';  // Store original query for language detection
	private onContentStreamCallback: ((stepIndex: number, chunk: string) => void) | null = null;
	protected contextManager: any | null = null;  // Context manager for file references (protected for subclass access)
	private memoryManager: MemoryManager | null = null;  // Memory manager instance
	private memory: Memory | null = null;  // Mastra Memory instance
	private threadId: string | null = null;  // Current thread ID for memory
	private resourceId: string | null = null;  // Current resource ID for memory
	private onSequentialStepError: ((step: AgentStep, stepIndex: number) => Promise<'skip' | 'retry' | 'regenerate'>) | null = null;  // Callback for sequential step errors
	
	constructor(config: MastraAgentConfig) {
		this.plugin = config.plugin;
		this.i18n = config.i18n;
		this.debug = config.debug ?? false;
		this.streamingManager = config.streamingManager || null;
		this.contextManager = config.contextManager || null;
		this.memoryManager = config.memoryManager || null;
		this.threadId = config.threadId || null;
		this.resourceId = config.resourceId || null;
		
		// Initialize PromptBuilder for consistent prompt generation
		this.promptBuilder = new PromptBuilder(
			this.i18n,
			() => this.getAvailableToolsDescription()
		);
		
		Logger.debug('[MastraAgent] Initializing with config:', {
			name: config.name,
			id: config.id,
			toolsCount: config.tools ? Object.keys(config.tools).length : 0,
			hasStreamingManager: !!this.streamingManager,
			hasMemoryManager: !!this.memoryManager,
			threadId: this.threadId,
			resourceId: this.resourceId
		});
	}
	
	/**
	 * Initialize the mastra agent instance
	 * This is separated from constructor to allow async initialization
	 */
	async initialize(config: MastraAgentConfig): Promise<void> {
		try {
			Logger.debug('[MastraAgent] Starting initialization...');
			
			Logger.debug('[MastraAgent] Tools received in initialize:', {
				count: config.tools ? Object.keys(config.tools).length : 0,
				names: config.tools ? Object.keys(config.tools) : []
			});
			
			// Get active provider from plugin
			const provider = this.plugin.getActiveProvider();
			if (!provider) {
				throw new Error('No active LLM provider configured');
			}
			
			// Convert LLMSider tools to mastra format
			// Use UnifiedToolManager.executeTool as the executor function
			const toolExecutor = async (name: string, args: unknown) => {
				const result = await this.plugin.toolManager.executeTool(name, args);
				if (!result.success) {
					throw new Error(result.error || 'Tool execution failed');
				}
				return result.result;
			};
			
			const mastraTools = convertToolsToMastraFormat(config.tools || {}, toolExecutor);
			
			// Get provider and model names
			const providerName = provider.getProviderName().toLowerCase();
			const modelName = provider.getModelName();
			
			// Mastra expects model as a string in format "provider/model-name"
			const modelId = `${providerName}/${modelName}`;
			
			Logger.debug('[MastraAgent] Model ID:', modelId);
			
			// Store provider, tools, and instructions for execution
			this.provider = provider;
			
			// Set thread ID on provider for session management (e.g. Free Qwen)
			if (this.threadId && this.provider.setThreadId) {
				this.provider.setThreadId(this.threadId);
			}

			this.tools = config.tools || {};
			this.instructions = config.instructions;
			
			// Create mastra agent configuration
			this.agentConfig = {
				id: config.id || config.name,
				name: config.name,
				instructions: config.instructions,
				model: modelId,
				tools: mastraTools,
				maxRetries: config.maxRetries ?? 2,
			};
			
			// Create real Mastra Agent instance if available
			if (Agent) {
				try {
					this.agent = new Agent(this.agentConfig);
					Logger.debug('[MastraAgent] Real Mastra Agent instance created');
				} catch (error) {
					Logger.warn('[MastraAgent] Failed to create Mastra Agent, using fallback:', error);
					this.agent = this.agentConfig; // Fallback to config
				}
			} else {
				Logger.debug('[MastraAgent] Using fallback implementation (Mastra not available)');
				this.agent = this.agentConfig;
			}
			
			// Create stream adapter if streaming manager is available
			if (this.streamingManager) {
				this.streamAdapter = new MastraStreamAdapter(this.streamingManager);
				Logger.debug('[MastraAgent] Stream adapter created');
			}
			
			// Initialize memory if memoryManager is provided
			if (this.memoryManager || config.memoryConfig) {
				await this.initializeMemory(config);
			}
			
			Logger.debug('[MastraAgent] Initialization complete');
		} catch (error) {
			Logger.error('[MastraAgent] Initialization failed:', error);
			throw error;
		}
	}
	
	/**
	 * Execute agent with plan-execute framework
	 * 
	 * This method:
	 * 1. Generates an execution plan from user input
	 * 2. Executes steps sequentially
	 * 3. Streams results back to caller
	 * 4. Handles errors and retries
	 */
	async execute(options: AgentExecuteOptions): Promise<void> {
		try {
			Logger.debug('[MastraAgent] Starting execution with options:', {
				messagesCount: options.messages.length,
				maxSteps: options.maxSteps,
				hasRealAgent: this.agent && typeof this.agent.stream === 'function'
			});
			
			// Try to use real Mastra Agent streaming if available
			if (this.agent && typeof this.agent.stream === 'function' && this.streamAdapter) {
				Logger.debug('[MastraAgent] Using Mastra native streaming');
				await this.executeWithMastraStream(options);
			} else {
				Logger.debug('[MastraAgent] Using fallback implementation');
				await this.executeWithFallback(options);
			}
			
		} catch (error) {
			Logger.error('[MastraAgent] Execution failed:', error);
			
			// Hide streaming indicator if present
			if (this.streamingManager) {
				this.streamingManager.hideStreamingIndicator();
			}
			
			throw error;
		}
	}
	
	/**
	 * Execute using Mastra's native streaming API
	 */
	private async executeWithMastraStream(options: AgentExecuteOptions): Promise<void> {
		// NOTE: Mastra's stream() API returns a non-standard object that cannot be
		// iterated with "for await...of", causing "TypeError: r is not async iterable".
		// Until we can properly handle Mastra's stream format, use fallback implementation.
		Logger.warn('[MastraAgent] Mastra native streaming not yet supported, using fallback');
		await this.executeWithFallback(options);
	}
	
	/**
	 * Execute using fallback implementation (direct LLM calls)
	 */
	private async executeWithFallback(options: AgentExecuteOptions): Promise<void> {
		// Store original user query for language detection
		const userMessage = options.messages.find(m => m.role === 'user');
		if (userMessage) {
			this.originalUserQuery = typeof userMessage.content === 'string' 
				? userMessage.content 
				: JSON.stringify(userMessage.content);
		}
		
		// Phase 1: Plan Generation
		let plan = await this.generatePlan(options.messages);
		
		// Phase 1.5: Plan Validation (Auto-fix removed - rely on prompts)
		const { PlanValidator } = await import('../../utils/plan-validator');
		
		// Set tools map for validator to access outputSchema
		PlanValidator.setToolsMap(this.tools);
		
		let validationResult = PlanValidator.validatePlan(plan.steps);
		
		if (!validationResult.valid) {
			Logger.warn('[MastraAgent] Plan validation failed:', validationResult);
			
			// Check if there are critical errors
			const hasCriticalErrors = validationResult.errors.length > 0;
			const errorMessage = PlanValidator.formatValidationResult(validationResult);
			
			if (hasCriticalErrors) {
				Logger.error('[MastraAgent] Plan validation errors:', errorMessage);
			}
			
			if (this.streamingManager) {
				this.streamingManager.showValidationResult(validationResult, { fixed: false, steps: plan.steps, changes: [] }, false);
			}
			
			// Block execution if critical errors exist
			if (hasCriticalErrors) {
				Logger.error('[MastraAgent] Blocking execution due to critical validation errors');
				// Create custom error with validation details
				const error = new Error(`Plan validation failed with ${validationResult.errors.length} critical error(s). Please regenerate the plan.`) as any;
				error.validationResult = validationResult;
				error.validationErrors = validationResult.errors.map(e => 
					`[${e.stepId}] ${e.errorType}: ${e.message}${e.suggestion ? ` (Âª∫ËÆÆ: ${e.suggestion})` : ''}`
				).join('\n');
				throw error;
			}
			
			// Only warnings - continue with caution
			Logger.warn('[MastraAgent] Continuing execution with validation warnings');
		} else {
			Logger.debug('[MastraAgent] Plan validation passed');
		}
		
		// Store plan for step input resolution
		this.currentPlan = plan;
		
		if (options.onPlanGenerated) {
			options.onPlanGenerated(plan);
		}
		
		// Phase 2: Determine execution mode and execute plan
		const executionMode = this.plugin.settings.planExecutionMode || 'sequential';
		Logger.debug(`[MastraAgent] Using execution mode: ${executionMode}`);
		
		// Use Mastra's native Workflow for execution
		await this.executePlanWithWorkflow(plan, options);
		
		// Agent Ê®°Âºè‰∏çÈúÄË¶ÅÁîüÊàê final answerÔºåÊâÄÊúâÊâßË°åÁªìÊûúÂ∑≤ÁªèÈÄöËøáÂ∑•ÂÖ∑ÊâßË°åÊòæÁ§∫
		Logger.debug('[MastraAgent] Plan execution completed, no final answer generation in agent mode');
	}

	/**
	 * Resume execution of an existing plan
	 * Skips already completed steps and executes pending/failed ones
	 */
	async resumePlan(plan: AgentPlan, options: AgentExecuteOptions): Promise<void> {
		Logger.debug(`[MastraAgent] Resuming plan: ${plan.id}`);
		this.currentPlan = plan;
		await this.executePlanWithWorkflow(plan, options);
	}

	/**
	 * Execute plan using Mastra's native Workflow DSL
	 */
	private async executePlanWithWorkflow(plan: AgentPlan, options: AgentExecuteOptions): Promise<void> {
		Logger.debug(`[MastraAgent] Building Mastra Workflow for plan: ${plan.id}`);
		
		const executionMode = this.plugin.settings.planExecutionMode || 'sequential';
		
		// 1. Create Mastra steps for each agent step
		const mastraSteps = plan.steps.map((step, index) => {
			return createStep({
				id: step.id,
				inputSchema: z.object({}),
				outputSchema: z.object({}),
				execute: async ({ getStepResult }) => {
					// Check for abort
					if (options.abortController?.signal.aborted) {
						throw new Error('Execution aborted by user');
					}

					// Check if step is already completed successfully (for retry/resume scenarios)
					if (step.status === 'completed' && step.result !== undefined) {
						Logger.debug(`[MastraAgent] Step ${step.id} already completed, skipping execution.`);
						return step.result;
					}

					// Build stepOutputs map for template resolution
					const stepOutputs = new Map<string, any>();
					const stepTools = new Map<string, string>();
					
					// Get results from all previous steps in the plan
					for (let i = 0; i < index; i++) {
						const prevStep = plan.steps[i];
						const result = getStepResult(prevStep.id);
						if (result) {
							stepOutputs.set(prevStep.id, result);
							stepTools.set(prevStep.id, prevStep.tool);
						}
					}

					// Resolve templates and execute step
					return await this.executeStepInternal(step, index, plan.steps.length, stepOutputs, stepTools, options);
				}
			});
		});

		// 2. Build the workflow graph
		let workflow = createWorkflow({
			id: plan.id,
			inputSchema: z.object({}),
			outputSchema: z.object({}),
		});

		if (executionMode === 'dag') {
			// DAG mode: Organize into layers and use .parallel()
			const layers = this.organizeIntoLayers(plan);
			for (const layer of layers) {
				const layerSteps = layer.map(s => mastraSteps.find(ms => ms.id === s.id)!);
				if (layerSteps.length > 1) {
					workflow = workflow.parallel(layerSteps);
				} else if (layerSteps.length === 1) {
					workflow = workflow.then(layerSteps[0]);
				}
			}
		} else {
			// Sequential mode: Chain steps with .then()
			for (const step of mastraSteps) {
				workflow = workflow.then(step);
			}
		}

		const committedWorkflow = workflow.commit();
		
		// 3. Execute the workflow
		const run = await committedWorkflow.createRunAsync();
		
		// Watch for events to update UI and handle status changes
		run.watch((event) => {
			if (event.type === 'watch' && event.payload.currentStep) {
				const { id, status, error, output } = event.payload.currentStep;
				const agentStep = plan.steps.find(s => s.id === id);
				
				if (agentStep) {
					let newStatus = this.convertMastraStatus(status);
					
					// Check if step actually failed but error was swallowed to allow workflow continuation
					if (newStatus === 'completed' && output && output._status === 'failed') {
						newStatus = 'failed';
					}
					
					// Only update and notify if status changed or it's a final state
					if (agentStep.status !== newStatus || newStatus === 'completed' || newStatus === 'failed') {
						agentStep.status = newStatus;
						if (error) {
							agentStep.error = error instanceof Error ? error.message : String(error);
						} else if (newStatus === 'failed' && output && output.error) {
							agentStep.error = output.error;
						}
						
						if (options.onStepExecuted) {
							options.onStepExecuted(agentStep);
						}
					}
				}
			}
		}, 'watch');

		try {
			await run.start({ inputData: {} });
		} catch (error) {
			Logger.error(`[MastraAgent] Workflow execution failed:`, error);
			throw error;
		}
	}

	/**
	 * Internal version of executeStep that takes pre-resolved step outputs
	 * This is used by the Mastra Workflow steps
	 */
	private async executeStepInternal(
		step: AgentStep, 
		stepIndex: number, 
		totalSteps: number,
		stepOutputs: Map<string, any>,
		stepTools: Map<string, string>,
		options: AgentExecuteOptions
	): Promise<any> {
		Logger.debug('[MastraAgent] Executing step internal:', step.id, 'tool:', step.tool);
		
		// Check for abort
		if (options.abortController?.signal.aborted) {
			throw new Error('Execution aborted by user');
		}
		
		// Resolve step input parameters using provided outputs
		let resolvedInput = this.resolveStepInputWithOutputs(step, stepOutputs, stepTools);
		
		// Normalize parameter names for common tools
		resolvedInput = this.normalizeToolParameters(step.tool, resolvedInput);
		
		// Record the request
		const toolCallInfo = {
			id: `tool_${Date.now()}`,
			toolName: step.tool,
			toolType: 'builtin' as const,
			parameters: resolvedInput as Record<string, unknown>,
			timestamp: new Date().toISOString(),
			startTime: new Date().toISOString()
		};
		
		const startTime = Date.now();
		
		try {
			let result: any;
			
			// Special handling for generate_content pseudo-tool
			if (step.tool === 'generate_content') {
				result = await this.generateContentWithLLM(resolvedInput, stepIndex, options);
				step.toolCalls = [{
					...toolCallInfo,
					response: { content: result },
					duration: Date.now() - startTime
				}];
				return { content: result };
			}
			
			// Special handling for for_each loop tool
			if (step.tool === 'for_each') {
				await this.executeForEach(step, resolvedInput, toolCallInfo, startTime, options);
				return step.toolCalls.map(tc => tc.response);
			}
			
			// Execute real tool
			// Create progress callback for tools that support it (like fetch_web_content)
			const onProgress = (content: string) => {
				if (this.onContentStreamCallback) {
					this.onContentStreamCallback(stepIndex, content);
				}
			};
			
			const toolResult = await this.plugin.toolManager.executeTool(step.tool, resolvedInput, { onProgress });
			const duration = Date.now() - startTime;
			
			if (!toolResult.success) {
				step.toolCalls = [{
					...toolCallInfo,
					error: toolResult.error || 'Tool execution failed',
					duration
				}];
				throw new Error(toolResult.error || 'Tool execution failed');
			}
			
			// Record successful response
			step.toolCalls = [{
				...toolCallInfo,
				response: toolResult.result as Record<string, unknown> | string,
				duration
			}];
			
			return toolResult.result;
			
		} catch (error) {
			const duration = Date.now() - startTime;
			const errorMessage = error instanceof Error ? error.message : String(error);
			
			if (!step.toolCalls) {
				step.toolCalls = [{
					...toolCallInfo,
					error: errorMessage,
					duration
				}];
			}
			
			// Don't throw error to allow workflow to continue (especially for DAG)
			// Instead, mark step as failed and return error object
			Logger.error(`[MastraAgent] Step ${step.id} failed but continuing workflow:`, error);
			step.status = 'failed';
			step.error = errorMessage;
			
			return { _status: 'failed', error: errorMessage };
		}
	}

	/**
	 * Resolve step input using provided step outputs (used by Workflow)
	 */
	private resolveStepInputWithOutputs(
		step: AgentStep, 
		stepOutputs: Map<string, any>,
		stepTools: Map<string, string>
	): Record<string, unknown> {
		let input: Record<string, unknown>;
		
		if (typeof step.input === 'string') {
			if (step.tool === 'web_search' || step.tool === 'duckduckgo_text_search' || 
			    step.tool === 'bing_search' || step.tool === 'google_search') {
				input = { query: step.input };
			} else if (step.tool === 'fetch_web_content') {
				input = { url: step.input };
			} else {
				input = { input: step.input };
			}
		} else if (typeof step.input === 'object' && step.input !== null) {
			input = { ...step.input } as Record<string, unknown>;
		} else {
			input = {};
		}
		
		// Resolve template strings in input
		const resolvedInput = this.resolveTemplates(input, stepOutputs, stepTools);
		
		// Special handling for fetch_web_content (Rescue logic)
		if (step.tool === 'fetch_web_content') {
			if (resolvedInput.urls && !resolvedInput.url) {
				resolvedInput.url = resolvedInput.urls;
				delete resolvedInput.urls;
			}
			
			if (!resolvedInput.url || (Array.isArray(resolvedInput.url) && resolvedInput.url.length === 0)) {
				const originalInput = input;
				const urlTemplate = originalInput.url || originalInput.urls;
				if (typeof urlTemplate === 'string') {
					const match = urlTemplate.match(/\{\{(step\d+)(?:\.([.\w\[\]]+))?\}\}/);
					if (match) {
						const [, stepId] = match;
						const stepOutput = stepOutputs.get(stepId);
						if (Array.isArray(stepOutput)) {
							resolvedInput.url = stepOutput;
						}
					}
				}
			}

			if (Array.isArray(resolvedInput.url)) {
				const urlArray = resolvedInput.url as any[];
				// Check if array contains objects (search results) that need URL extraction
				// We check the first valid object to determine if this is a list of search results
				const firstValidObject = urlArray.find(item => item && typeof item === 'object');
				
				if (firstValidObject) {
					const extractedUrls = urlArray
						.filter((item: any) => item && typeof item === 'object') // Filter out null/undefined/primitives
						.map((item: any) => item.url || item.link)
						.filter((url: string) => url && typeof url === 'string')
						.slice(0, 10);
					
					if (extractedUrls.length > 0) {
						resolvedInput.url = extractedUrls;
					}
				}
			}
		}
		
		return resolvedInput;
	}

	/**
	 * Organize steps into layers by dependency depth for DAG execution
	 */
	private organizeIntoLayers(plan: AgentPlan): AgentStep[][] {
		const layers: AgentStep[][] = [];
		const stepDepths = new Map<string, number>();
		
		const calculateDepth = (step: AgentStep): number => {
			if (stepDepths.has(step.id)) {
				return stepDepths.get(step.id)!;
			}
			
			if (!step.dependencies || step.dependencies.length === 0) {
				stepDepths.set(step.id, 0);
				return 0;
			}
			
			const depSteps = plan.steps.filter(s => step.dependencies!.includes(s.id));
			const depthsOfDeps = depSteps.map(s => calculateDepth(s));
			const depth = depthsOfDeps.length > 0 ? Math.max(...depthsOfDeps) + 1 : 0;
			stepDepths.set(step.id, depth);
			return depth;
		};
		
		plan.steps.forEach(step => calculateDepth(step));
		plan.steps.forEach(step => {
			const depth = stepDepths.get(step.id)!;
			if (!layers[depth]) {
				layers[depth] = [];
			}
			layers[depth].push(step);
		});
		
		return layers;
	}

	/**
	 * Generate execution plan from user messages
	 */
	private async generatePlan(messages: ChatMessage[]): Promise<AgentPlan> {
		Logger.debug('[MastraAgent] Generating plan from messages...');
		
		// Show plan generation indicator
		if (this.streamingManager) {
			this.streamingManager.createSimplePlanGenerationIndicator(
				this.i18n.t('planExecute.generating')
			);
		}
		
		// Extract last user message as the main query
		const userMessage = messages.filter(m => m.role === 'user').pop();
		if (!userMessage) {
			throw new Error('No user message found');
		}
		
		if (!this.provider) {
			throw new Error('No provider initialized');
		}
		
		// Build planning prompt using PromptBuilder
		const userContent = typeof userMessage.content === 'string' ? userMessage.content : JSON.stringify(userMessage.content);
		const planningPrompt = await this.buildPlanningPrompt(userContent, messages);
		
		// Create planning messages - use planningPrompt as user message directly
		// since it already contains system instructions and format requirements
		const planningMessages: ChatMessage[] = [
			{
				id: 'user-plan-' + Date.now(),
				role: 'user',
				content: planningPrompt,
				timestamp: Date.now()
			}
		];
		
		// Track elapsed time for user feedback
		const startTime = Date.now();
		let progressInterval: number | null = null;
		
		try {
			// Update progress indicator every 1 second
			if (this.streamingManager) {
				progressInterval = window.setInterval(() => {
					const elapsed = Math.floor((Date.now() - startTime) / 1000);
					this.streamingManager?.updateStreamingIndicator(
						`${this.i18n.t('planExecute.generating')} (${elapsed}s)`
					);
				}, 1000);
			}
			
		// Call LLM to generate plan
		let planText = '';
		let apiError: Error | null = null;
		
		Logger.debug('[MastraAgent] ===== Starting API call to generate plan =====');
		let chunkCount = 0;
		try {
			Logger.debug('[MastraAgent] Calling provider.sendStreamingMessage...');
			
			// Set thread ID on provider for session management (e.g. Free Qwen)
			if (this.threadId && this.provider.setThreadId) {
				this.provider.setThreadId(this.threadId);
			}

			await this.provider.sendStreamingMessage(
				planningMessages,
				(chunk) => {
					chunkCount++;
					// Logger.debug('[MastraAgent] üì¶ Received chunk #' + chunkCount + ':', {
					// 	hasDelta: !!chunk.delta,
					// 	deltaLength: chunk.delta?.length || 0,
					// 	isComplete: chunk.isComplete,
					// 	hasMetadata: !!chunk.metadata
					// });
					if (chunk.delta) {
						planText += chunk.delta;
						// Logger.debug('[MastraAgent] Added delta, current planText length:', planText.length);
					}
					if (chunk.metadata) {
						// Logger.warn('[MastraAgent] ‚ö†Ô∏è Chunk has metadata:', chunk.metadata);
					}
				}
			);
			Logger.debug('[MastraAgent] ‚úÖ sendStreamingMessage completed');
			Logger.debug('[MastraAgent] Total chunks received:', chunkCount);
			Logger.debug('[MastraAgent] Final planText length:', planText.length);
			Logger.debug('[MastraAgent] planText preview:', planText);
		} catch (error) {
			// Capture API error to preserve it
			apiError = error as Error;
			Logger.error('[MastraAgent] ‚ùå API call CAUGHT ERROR in inner try-catch');
			Logger.error('[MastraAgent] Error object:', error);
			Logger.error('[MastraAgent] Error type:', error?.constructor?.name);
			Logger.error('[MastraAgent] Error message:', (error as Error)?.message);
			Logger.error('[MastraAgent] Error stack:', (error as Error)?.stack);
			Logger.error('[MastraAgent] Saving error to apiError variable for later throw');
			// Don't throw yet - will check and throw after cleanup
		}
		
		// Clear progress interval
		Logger.debug('[MastraAgent] Cleaning up progress interval...');
		if (progressInterval) {
			window.clearInterval(progressInterval);
			Logger.debug('[MastraAgent] Progress interval cleared');
		}
		
		Logger.debug('[MastraAgent] ===== Checking results after API call =====');
		Logger.debug('[MastraAgent] apiError is null?', apiError === null);
		Logger.debug('[MastraAgent] planText length:', planText.length);
		Logger.debug('[MastraAgent] planText preview:', planText);
		
		// If we have an API error, always throw it (regardless of planText)
		if (apiError) {
			Logger.error('[MastraAgent] ‚ö†Ô∏è API ERROR DETECTED - Re-throwing to preserve original error');
			Logger.error('[MastraAgent] About to throw error:', apiError.message);
			Logger.error('[MastraAgent] Error type being thrown:', apiError.constructor.name);
			throw apiError;
		}
		
		Logger.debug('[MastraAgent] No API error detected, checking planText...');
		// Check if we actually received content (only if no API error)
		if (!planText || planText.trim().length === 0) {
			Logger.error('[MastraAgent] ‚ùå planText is empty, throwing new error');
			throw new Error('No plan content received from LLM');
		}
		
		Logger.debug('[MastraAgent] ‚úÖ planText validated, proceeding to parse...');
		
		// Parse plan from response
		const plan = this.parsePlanFromResponse(planText);
			
			// Validate parsed plan
			if (!plan.steps || plan.steps.length === 0) {
				throw new Error('Failed to parse plan: no valid steps found');
			}
			
			Logger.debug('[MastraAgent] Plan generated with', plan.steps.length, 'steps');
			Logger.debug('[MastraAgent] ===== COMPLETE PLAN DETAILS =====');
			Logger.debug('[MastraAgent] Full plan object:', JSON.stringify(plan, null, 2));
			
			// Hide plan generation indicator (will be replaced by plan display)
			if (this.streamingManager) {
				this.streamingManager.hideStreamingIndicator();
			}
			
			return plan;
			
		} catch (error) {
			Logger.error('[MastraAgent] ===== OUTER CATCH BLOCK CAUGHT ERROR =====');
			Logger.error('[MastraAgent] Error in outer catch:', error);
			Logger.error('[MastraAgent] Error type:', error?.constructor?.name);
			Logger.error('[MastraAgent] Error message:', (error as Error)?.message);
			Logger.error('[MastraAgent] Error stack:', (error as Error)?.stack);
			
			// Clear progress interval
			Logger.debug('[MastraAgent] Cleaning up in outer catch...');
			if (progressInterval) {
				window.clearInterval(progressInterval);
			}
			
			// Hide indicator on error
			if (this.streamingManager) {
				this.streamingManager.hideStreamingIndicator();
			}
			
			Logger.error('[MastraAgent] About to re-throw error from outer catch');
			Logger.error('[MastraAgent] Re-throwing error type:', error?.constructor?.name);
			Logger.error('[MastraAgent] Re-throwing error message:', (error as Error)?.message);
			// Re-throw original error to preserve error details (API errors, parsing errors, etc.)
			throw error;
		}
	}
	
	/**
	 * Get available tools description for prompt
	 * Now includes outputSchema information to help with step-to-step data passing
	 */
	private async getAvailableToolsDescription(): Promise<string> {
		// Import zod-to-json-schema once for all tools
		const { zodToJsonSchema } = await import('zod-to-json-schema');
		
		Logger.debug('[MastraAgent] getAvailableToolsDescription - this.tools:', {
			count: Object.keys(this.tools).length,
			names: Object.keys(this.tools)
		});
		
		const toolDescriptions = await Promise.all(Object.values(this.tools).map(async tool => {
			// Get input parameters from schema
			const schema = (tool as any).schema;
			let params = '  No parameters';
			
			if (schema?.parameters) {
				params = Object.entries(schema.parameters).map(([name, paramSchema]: [string, any]) => {
					const required = paramSchema.required ? ' (required)' : '';
					const type = paramSchema.type || 'any';
					const desc = paramSchema.description || '';
					let details = '';
					
					// Add details for array/object types
					if (type === 'array' && paramSchema.items) {
						details = ` (Array of ${paramSchema.items.type || 'any'})`;
					} else if (type === 'object' && paramSchema.properties) {
						details = ` (Object with keys: ${Object.keys(paramSchema.properties).join(', ')})`;
					}
					
					// Extract examples from description if present
					let exampleLine = '';
					if (desc) {
						// Look for "Examples:" or "Example:" or patterns like ["TSLA"] in description
						const exampleMatch = desc.match(/Examples?:\s*(.+?)(?:\.|$)/i);
						if (exampleMatch) {
							exampleLine = `\n    üí° Example: ${exampleMatch[1].trim()}`;
						} else {
							// Try to find JSON-like examples in brackets
							const jsonExamples = desc.match(/\[["'][^"'\]]+["'](?:,\s*["'][^"'\]]+["'])?\]/g);
							if (jsonExamples && jsonExamples.length > 0) {
								exampleLine = `\n    üí° Example: ${jsonExamples[0]}`;
							}
						}
					}
					
					return `  - ${name}${required}: ${type}${details} - ${desc}${exampleLine}`;
				}).join('\n');
			}
			
		// Get output schema information if available
		let outputInfo = '';
		const outputSchema = (tool as any).outputSchema;
		if (outputSchema) {
			outputInfo = '\n### Output Format:\n';
			
			// Convert Zod schema to JSON Schema if needed
			let jsonSchema: any = outputSchema;
			if (outputSchema._def || outputSchema['~standard']) {
				// This is a Zod schema, convert it to JSON Schema
				try {
					jsonSchema = zodToJsonSchema(outputSchema, {
						target: 'openApi3',
						$refStrategy: 'none'
					});
					// Logger.debug(`[MastraAgent] Converted Zod outputSchema to JSON Schema for ${tool.name}`);
				} catch (error) {
					Logger.warn(`[MastraAgent] Failed to convert Zod schema for ${tool.name}, using original:`, error);
				}
			}				// Format output schema description
				if (jsonSchema.description) {
					outputInfo += `${jsonSchema.description}\n`;
				}
				
				// Format output structure
				if (jsonSchema.type === 'object' && jsonSchema.properties) {
					outputInfo += 'Output Fields:\n';
					Object.entries(jsonSchema.properties).forEach(([fieldName, fieldSchema]: [string, any]) => {
						const fieldType = fieldSchema.type || 'any';
						const fieldDesc = fieldSchema.description || '';
						outputInfo += `  - ${fieldName}: ${fieldType}${fieldDesc ? ' - ' + fieldDesc : ''}\n`;
						
						// If field is an array with nested object properties, show them
						if (fieldType === 'array' && fieldSchema.items?.type === 'object' && fieldSchema.items?.properties) {
							outputInfo += `    Array items contain:\n`;
							Object.entries(fieldSchema.items.properties).forEach(([itemFieldName, itemFieldSchema]: [string, any]) => {
								const itemFieldType = itemFieldSchema.type || 'any';
								const itemFieldDesc = itemFieldSchema.description || '';
								outputInfo += `      ‚Ä¢ ${itemFieldName}: ${itemFieldType}${itemFieldDesc ? ' - ' + itemFieldDesc : ''}\n`;
							});
						}
					});
				} else if (jsonSchema.type === 'array' && jsonSchema.items) {
					outputInfo += `Returns: array of ${jsonSchema.items.type || 'items'}\n`;
					if (jsonSchema.items.properties) {
						outputInfo += 'Array Item Fields:\n';
						Object.entries(jsonSchema.items.properties).forEach(([fieldName, fieldSchema]: [string, any]) => {
							const fieldType = fieldSchema.type || 'any';
							const fieldDesc = fieldSchema.description || '';
							outputInfo += `  - ${fieldName}: ${fieldType}${fieldDesc ? ' - ' + fieldDesc : ''}\n`;
						});
					}
				} else if (jsonSchema.type === 'string') {
					outputInfo += `Returns: string${jsonSchema.description ? ' - ' + jsonSchema.description : ''}\n`;
				}
				
				// Add example if available
				if (jsonSchema.example) {
					const exampleStr = typeof jsonSchema.example === 'string' 
						? jsonSchema.example 
						: JSON.stringify(jsonSchema.example, null, 2);
					// Truncate long examples
					const truncatedExample = exampleStr.length > 200 
						? exampleStr.substring(0, 200) + '...' 
						: exampleStr;
					outputInfo += `\nExample Output:\n${truncatedExample}\n`;
				}

				// Add raw JSON Schema for precise reference (now using converted schema)
				outputInfo += `\n### Output Schema (JSON):\n${JSON.stringify(jsonSchema, null, 2)}\n`;
				
			// Add guidance for template usage
			outputInfo += `\nüí° Access in next step: {{stepX.fieldName}} or {{stepX}}\n`;
		}
		
		return `## ${tool.name}\n${tool.description}\n### Parameters:\n${params}${outputInfo}`;
	}));
	
	return toolDescriptions.join('\n\n');
}	/**
	 * Build planning prompt from user query using PromptBuilder
	 * This ensures consistency with the original plan-execute implementation
	 * but adapts the output format for Mastra's JSON parsing
	 */
	private async buildPlanningPrompt(query: string, context: ChatMessage[]): Promise<string> {
		// Get available tools description
		const availableTools = await this.getAvailableToolsDescription();
		
		// Extract attached files from ContextManager for planning
		let contextInfo = '';
		const attachedFiles: { name: string; path: string; type?: string }[] = [];
		
		Logger.debug('[CONTEXT-EXTRACT] Starting context extraction from ContextManager');
		
		// Try to get files from ContextManager (files added via "Add Context" button)
		if (this.contextManager) {
			try {
				const noteContexts = this.contextManager.getCurrentNoteContext();
				
				Logger.debug('[CONTEXT-EXTRACT] Retrieved note contexts:', {
					count: noteContexts.length,
					contexts: noteContexts.map(nc => ({
						name: nc.name,
						filePath: nc.filePath,
						type: nc.type,
						contentLength: nc.content?.length || 0
					}))
				});
				
				for (const noteContext of noteContexts) {
					if (noteContext.name) {
						attachedFiles.push({
							name: noteContext.name,
							path: noteContext.filePath || noteContext.name,
							type: noteContext.type
						});
						Logger.debug('[CONTEXT-EXTRACT] Added file from ContextManager:', {
							name: noteContext.name,
							path: noteContext.filePath,
							type: noteContext.type
						});
					}
				}
			} catch (error) {
				Logger.error('[CONTEXT-EXTRACT] Error extracting from ContextManager:', error);
			}
		} else {
			Logger.debug('[CONTEXT-EXTRACT] No ContextManager available');
		}
		
		Logger.debug('[CONTEXT-EXTRACT] Extraction complete:', {
			totalFiles: attachedFiles.length,
			files: attachedFiles
		});
		
		if (attachedFiles.length > 0) {
			const fileList = attachedFiles.map(f => `- ${f.name}${f.path !== f.name ? ` (Ë∑ØÂæÑ: ${f.path})` : ''}`).join('\n');
			const examplePath = attachedFiles[0].path || attachedFiles[0].name;
			
			contextInfo = `Áî®Êà∑Â∑≤ÈôÑÂä†‰ª•‰∏ãÊñá‰ª∂ÔºàÂÆåÊï¥ÂÜÖÂÆπÂ∑≤Âú®Á≥ªÁªüÊèêÁ§∫ËØç‰∏≠ÔºâÔºö
${fileList}

**ÈáçË¶ÅËßÑÂàô**Ôºö
1. ÂΩìÁî®Êà∑ËØ¥"Ê†πÊçÆËøô‰∏™"„ÄÅ"Âü∫‰∫éËøô‰∏™"„ÄÅ"ÂèÇËÄÉËøô‰∏™"Êó∂ÔºåÊåáÁöÑÊòØ‰∏äËø∞ÈôÑÂä†Êñá‰ª∂
2. ÈôÑÂä†Êñá‰ª∂ÁöÑÂÆåÊï¥ÂÜÖÂÆπÂ∑≤ÂåÖÂê´Âú®Á≥ªÁªüÊèêÁ§∫ËØç‰∏≠Ôºå‰Ω†ÂèØ‰ª•Áõ¥Êé•‰ΩøÁî®
3. **Á¶ÅÊ≠¢**Â∞ÜÂÆåÊï¥Êñá‰ª∂ÂÜÖÂÆπ‰Ωú‰∏∫ÊêúÁ¥¢Êü•ËØ¢Ôºà‰ºöÂõ†ËøáÈïøËÄåÂ§±Ë¥•Ôºâ

**ÂÖ≥ÈîÆËßÑÂàô - ‰ΩïÊó∂ÈúÄË¶ÅÊÄªÁªìÊ≠•È™§**Ôºö
‚ö†Ô∏è **‰ªÖÂΩìÊª°Ë∂≥‰ª•‰∏ãÊù°‰ª∂Êó∂ÔºåÊâçÈúÄË¶ÅÂÖàÁî® generate_content ÊÄªÁªì**Ôºö
- Áî®Êà∑Ë¶ÅÊ±ÇÂü∫‰∫éÈôÑÂä†Êñá‰ª∂ÂÜÖÂÆπËøõË°å**ÁΩëÁªúÊêúÁ¥¢**
- ‰æãÂ¶ÇÔºö"Ê†πÊçÆËøô‰∏™Á¨îËÆ∞ÊêúÁ¥¢XXX"„ÄÅ"Âü∫‰∫éËøôÁØáÊñáÁ´†Êü•ÊâæËµÑÊñô"

Âú®ËøôÁßçÊÉÖÂÜµ‰∏ãÔºåÊ≠£Á°ÆÊµÅÁ®ãÊòØÔºö
‚Üí step1: generate_content(task="ÊèêÂèñÊñá‰ª∂‰∏≠ÂÖ≥‰∫éXXXÁöÑÊ†∏ÂøÉ‰ø°ÊÅØÔºåÁîüÊàê2-3‰∏™ÊêúÁ¥¢ÂÖ≥ÈîÆËØçÔºà20Â≠ó‰ª•ÂÜÖÔºâ")
‚Üí step2: duckduckgo_text_search(query="{{step1.content}}")
‚Üí step3: Â§ÑÁêÜÊêúÁ¥¢ÁªìÊûú...

**Êó†ÈúÄÊÄªÁªìÁöÑÊÉÖÂÜµ**ÔºàÁõ¥Êé•‰ΩøÁî®Êñá‰ª∂ÂÜÖÂÆπÔºâÔºö
- Áî®Êà∑Âè™Ë¶ÅÊ±Ç"Ê†πÊçÆËøô‰∏™Êñá‰ª∂ÁîüÊàêXXX"ÔºàÊó†ÊêúÁ¥¢ÈúÄÊ±ÇÔºâ
  ‚Üí step1: generate_content(task="Âü∫‰∫éÈôÑÂä†Êñá‰ª∂ÂÜÖÂÆπÁîüÊàêXXX")
- Áî®Êà∑Ë¶ÅÊ±Ç"ÂàÜÊûêËøô‰∏™Êñá‰ª∂"„ÄÅ"ÊÄªÁªìËøôÁØáÊñáÁ´†"
  ‚Üí step1: generate_content(task="ÂàÜÊûê/ÊÄªÁªìÊñá‰ª∂ÂÜÖÂÆπ")

**‰ªÖÂú®‰ª•‰∏ãÊÉÖÂÜµ‰ΩøÁî® view Â∑•ÂÖ∑**Ôºö
- ÈúÄË¶ÅÊü•Áúã**Êú™ÈôÑÂä†**ÁöÑÂÖ∂‰ªñÊñá‰ª∂Êó∂ÔºàË∑ØÂæÑÁ§∫‰æãÔºö"${examplePath}"Ôºâ`;
			
			Logger.debug('[CONTEXT-EXTRACT] Built contextInfo:', {
				length: contextInfo.length,
				preview: contextInfo.substring(0, 200)
			});
		} else {
			Logger.warn('[CONTEXT-EXTRACT] No attached files found in ContextManager!');
		}
		
		// Use PromptBuilder's buildPlanPhasePrompt which now outputs pure JSON format directly
		// Get execution mode from settings
		const executionMode = this.plugin.settings.planExecutionMode || 'sequential';
		return this.promptBuilder.buildPlanPhasePrompt(query, availableTools, contextInfo, executionMode);
	}
	
	/**
	 * Auto-infer dependencies based on placeholder usage ({{stepX.output}})
	 * This is a fallback when LLM fails to generate dependencies
	 */
	private inferDependencies(steps: AgentStep[]): void {
		Logger.debug('[MastraAgent] ===== AUTO-INFERRING DEPENDENCIES =====');
		
		steps.forEach(step => {
			const inputStr = typeof step.input === 'string' 
				? step.input 
				: JSON.stringify(step.input);
			
			// Find all {{stepX.field}} or {{stepX}} patterns
			const placeholderPattern = /\{\{(step\d+)(?:\.[^}]+)?\}\}/g;
			const matches = inputStr.matchAll(placeholderPattern);
			
			const inferredDeps = new Set<string>();
			for (const match of matches) {
				const depStepId = match[1]; // e.g., "step1"
				inferredDeps.add(depStepId);
			}
			
			if (inferredDeps.size > 0) {
				step.dependencies = Array.from(inferredDeps);
				Logger.debug(`[MastraAgent] ‚úì Inferred dependencies for ${step.id}:`, step.dependencies);
			} else {
				step.dependencies = [];
				Logger.debug(`[MastraAgent] ‚óã No dependencies inferred for ${step.id} (independent)`);
			}
		});
		
		Logger.debug('[MastraAgent] ===== DEPENDENCY INFERENCE COMPLETE =====');
	}
	
	/**
	 * Parse plan from LLM response
	 * Handles multiple formats:
	 * - Pure JSON: {"steps": [...]}
	 * - Markdown code block: ```json\n{...}\n```
	 * - XML wrapped: <plan>{...}</plan>
	 * - Mixed formats with surrounding text
	 */
	private parsePlanFromResponse(response: string): AgentPlan {
		try {
			let jsonText = response;
			
			// 1. Try to extract from <plan> XML tags first (original format)
			const planTagMatch = response.match(/<plan>\s*([\s\S]*?)\s*<\/plan>/);
			if (planTagMatch) {
				jsonText = planTagMatch[1];
				Logger.debug('[MastraAgent] Extracted JSON from <plan> tags');
			}
			
			// 2. Try to extract from markdown code blocks
			const codeBlockMatch = jsonText.match(/```(?:json)?\s*\n?([\s\S]*?)```/);
			if (codeBlockMatch) {
				jsonText = codeBlockMatch[1];
				Logger.debug('[MastraAgent] Extracted JSON from markdown code block');
			}
			
			// 3. Try to find JSON object boundaries in the text
			const jsonStart = jsonText.indexOf('{');
			const jsonEnd = jsonText.lastIndexOf('}');
			if (jsonStart !== -1 && jsonEnd !== -1) {
				jsonText = jsonText.substring(jsonStart, jsonEnd + 1);
			}
			
			// 4. Clean up common JSON formatting issues
			// Remove trailing commas before closing braces/brackets (common LLM mistake)
			jsonText = jsonText.replace(/,(\s*[}\]])/g, '$1');
			// Remove control characters that might break JSON parsing
			jsonText = jsonText.replace(/[\x00-\x1F\x7F-\x9F]/g, '');
			
			// 5. Parse the JSON
			let parsed: any;
			try {
				parsed = JSON.parse(jsonText);
			} catch (parseError) {
				// If parsing fails, try to provide more context
				const errorMsg = parseError instanceof Error ? parseError.message : String(parseError);
				const errorMatch = errorMsg.match(/position (\d+)/);
				
				if (errorMatch) {
					const position = parseInt(errorMatch[1]);
					const contextStart = Math.max(0, position - 100);
					const contextEnd = Math.min(jsonText.length, position + 100);
					const context = jsonText.substring(contextStart, contextEnd);
					
					Logger.error('[MastraAgent] JSON parse error context:', {
						position,
						before: context.substring(0, 100),
						after: context.substring(100)
					});
				}
				
				throw parseError;
			}
			
			// 6. Validate and convert to AgentStep format
			if (!parsed.steps || !Array.isArray(parsed.steps)) {
				throw new Error('Invalid plan format: missing or invalid "steps" array');
			}
			
			const steps: AgentStep[] = parsed.steps.map((step: any, index: number) => {
				// Validate required fields
				if (!step.tool) {
					Logger.warn(`[MastraAgent] Step ${index + 1} missing tool name, skipping`);
					return null;
				}
				
				return {
					id: step.step_id || `step_${index + 1}`,
					tool: step.tool,
					input: step.input || {},
					reason: step.reason || '',
					status: 'pending' as const,
					dependencies: step.dependencies || [], // CRITICAL: Preserve dependencies from LLM
					outputSchema: step.outputSchema // Capture outputSchema for validation
				};
			}).filter(step => step !== null) as AgentStep[];
			
			Logger.debug(`[MastraAgent] Successfully parsed plan with ${steps.length} steps`);
			
			// Auto-infer dependencies if all steps have empty dependencies
			const stepsWithDeps = steps.filter(s => s.dependencies && s.dependencies.length > 0);
			if (stepsWithDeps.length === 0 && steps.length > 1) {
				Logger.warn('[MastraAgent] ‚ö†Ô∏è No dependencies detected in plan! Auto-inferring from placeholders...');
				this.inferDependencies(steps);
			}
			
			return {
				id: `plan_${Date.now()}`,
				steps,
				estimatedTokens: response.length / 4 // Rough estimate
			};
			
		} catch (error) {
			Logger.error('[MastraAgent] Failed to parse plan:', error);
			Logger.debug('[MastraAgent] Raw response preview:', response.substring(0, 500));
			Logger.debug('[MastraAgent] Raw response length:', response.length);
			
			// Re-throw with more context
			const errorMsg = error instanceof Error ? error.message : String(error);
			throw new Error(`Failed to parse plan from LLM response: ${errorMsg}`);
		}
	}
	
	/**
	 * Execute for_each loop - iterates over an array and executes a tool for each item
	 */
	private async executeForEach(
		step: AgentStep,
		resolvedInput: Record<string, unknown>,
		toolCallInfo: any,
		startTime: number,
		options: AgentExecuteOptions
	): Promise<void> {
		Logger.debug('[Mastra] executeForEach: START', { 
			stepId: step.id, 
			resolvedInputKeys: Object.keys(resolvedInput),
			timestamp: new Date().toISOString()
		});
		
		const { items, tool_name, tool_input } = resolvedInput;
		
		Logger.debug('[Mastra] executeForEach: Extracted parameters', {
			hasItems: !!items,
			itemsType: Array.isArray(items) ? 'array' : typeof items,
			itemsLength: Array.isArray(items) ? items.length : 'N/A',
			toolName: tool_name,
			toolInputKeys: tool_input ? Object.keys(tool_input) : 'undefined'
		});
		
		// Validate inputs
		if (!Array.isArray(items)) {
			const error = 'for_each requires an array of items';
			Logger.error('[Mastra] executeForEach: VALIDATION FAILED - items not array', {
				itemsType: typeof items,
				itemsValue: items
			});
			step.toolCalls = [{
				...toolCallInfo,
				error,
				duration: Date.now() - startTime
			}];
			step.status = 'failed';
			step.error = error;
			throw new Error(error);
		}
		
		if (!tool_name || typeof tool_name !== 'string') {
			const error = 'for_each requires a valid tool_name';
			Logger.error('[Mastra] executeForEach: VALIDATION FAILED - invalid tool_name', {
				toolName: tool_name,
				toolNameType: typeof tool_name
			});
			step.toolCalls = [{
				...toolCallInfo,
				error,
				duration: Date.now() - startTime
			}];
			step.status = 'failed';
			step.error = error;
			throw new Error(error);
		}
		
		Logger.debug(`[Mastra] executeForEach: VALIDATION PASSED - Processing ${items.length} items with tool ${tool_name}`);
		
		const toolCalls: any[] = [];
		const results: any[] = [];
		
		Logger.debug('[Mastra] executeForEach: Starting iteration loop', {
			totalItems: items.length,
			toolName: tool_name
		});
		
		// Execute tool for each item
		for (let i = 0; i < items.length; i++) {
			// Check for abort
			if (options.abortController?.signal.aborted) {
				Logger.debug('[Mastra] executeForEach: Aborted by user');
				break;
			}

			// Yield to UI every iteration to prevent blocking
			// Use 10ms delay to give UI thread enough time to respond
			await new Promise(resolve => setTimeout(resolve, 10));
			
			const item = items[i];
			const iterationStartTime = Date.now();
			
			Logger.debug(`[Mastra] executeForEach: Iteration ${i + 1}/${items.length} START`, {
				item: typeof item === 'string' ? item : JSON.stringify(item).substring(0, 100),
				itemType: typeof item
			});
			
			// Resolve tool_input template variables with current item
			Logger.debug(`[Mastra] executeForEach: Resolving tool_input for iteration ${i + 1}`, {
				toolInputBefore: JSON.stringify(tool_input).substring(0, 200)
			});
			
			const resolvedToolInput = this.resolveForEachInput(tool_input as Record<string, unknown>, item, i);
			
			Logger.debug(`[Mastra] executeForEach: Resolved tool_input for iteration ${i + 1}`, {
				resolvedToolInput: JSON.stringify(resolvedToolInput).substring(0, 200)
			});
			
			// Create tool call record for this iteration
			const iterationToolCall = {
				id: `tool_${Date.now()}_iter${i}`,
				toolName: tool_name,
				toolType: 'builtin' as const,
				parameters: resolvedToolInput,
				timestamp: new Date().toISOString(),
				startTime: new Date().toISOString()
			};
			
			try {
				// Execute the tool
				Logger.debug(`[Mastra] executeForEach: Calling executeTool for iteration ${i + 1}`, {
					toolName: tool_name,
					parameters: JSON.stringify(resolvedToolInput).substring(0, 300)
				});
				
				const result = await this.plugin.toolManager.executeTool(
					tool_name as string,
					resolvedToolInput
				);
				
				const iterationDuration = Date.now() - iterationStartTime;
				
				Logger.debug(`[Mastra] executeForEach: Tool execution completed for iteration ${i + 1}`, {
					success: result.success,
					duration: iterationDuration,
					hasError: !!result.error,
					hasResult: !!result.result
				});
				
				if (!result.success) {
					// Record error but continue with next items
					toolCalls.push({
						...iterationToolCall,
						error: result.error || 'Tool execution failed',
						duration: iterationDuration
					});
					Logger.warn(`[Mastra] executeForEach: Iteration ${i + 1}/${items.length} FAILED`, {
						error: result.error,
						duration: iterationDuration
					});
				} else {
					// Record success
					toolCalls.push({
						...iterationToolCall,
						response: result.result,
						duration: iterationDuration
					});
					results.push(result.result);
					Logger.debug(`[Mastra] executeForEach: Iteration ${i + 1}/${items.length} SUCCESS`, {
						duration: iterationDuration
					});
				}
			} catch (error) {
				const iterationDuration = Date.now() - iterationStartTime;
				const errorMessage = error instanceof Error ? error.message : String(error);
				
				toolCalls.push({
					...iterationToolCall,
					error: errorMessage,
					duration: iterationDuration
				});
				Logger.error(`[Mastra] executeForEach: Iteration ${i + 1}/${items.length} THREW EXCEPTION`, {
					error: errorMessage,
					errorStack: error instanceof Error ? error.stack : undefined,
					duration: iterationDuration
				});
			}
			
			// Progress update every 5 iterations or at end
			if ((i + 1) % 5 === 0 || i === items.length - 1) {
				const successSoFar = toolCalls.filter(tc => !tc.error).length;
				Logger.debug(`[Mastra] executeForEach: Progress update`, {
					completed: i + 1,
					total: items.length,
					successCount: successSoFar,
					failureCount: (i + 1) - successSoFar,
					percentComplete: Math.round(((i + 1) / items.length) * 100)
				});
			}
		}
		
		Logger.debug('[Mastra] executeForEach: All iterations completed', {
			totalIterations: items.length,
			toolCallsRecorded: toolCalls.length
		});
		
		// Record all iterations
		Logger.debug('[Mastra] executeForEach: Recording toolCalls to step', {
			toolCallsCount: toolCalls.length
		});
		step.toolCalls = toolCalls;
		
		// Check if any iterations succeeded
		const successCount = toolCalls.filter(tc => !tc.error).length;
		const failureCount = items.length - successCount;
		const totalDuration = Date.now() - startTime;
		
		Logger.debug('[Mastra] executeForEach: Computing final status', {
			successCount,
			failureCount,
			totalItems: items.length,
			totalDuration
		});
		
		if (successCount === 0) {
			step.status = 'failed';
			step.error = `for_each: All ${items.length} iterations failed`;
			Logger.error('[Mastra] executeForEach: FINAL STATUS = FAILED (all iterations failed)', {
				totalItems: items.length,
				totalDuration
			});
			throw new Error(step.error);
		} else if (successCount < items.length) {
			// Partial success - mark as completed but log warning
			step.status = 'completed';
			Logger.warn(`[Mastra] executeForEach: FINAL STATUS = PARTIAL SUCCESS`, {
				successCount,
				failureCount,
				totalItems: items.length,
				successRate: `${Math.round((successCount / items.length) * 100)}%`,
				totalDuration
			});
		} else {
			step.status = 'completed';
			Logger.debug(`[Mastra] executeForEach: FINAL STATUS = SUCCESS (all iterations completed)`, {
				totalItems: items.length,
				totalDuration,
				avgDurationPerItem: Math.round(totalDuration / items.length)
			});
		}
		
		Logger.debug('[Mastra] executeForEach: END', {
			stepId: step.id,
			finalStatus: step.status,
			timestamp: new Date().toISOString()
		});
	}
	
	/**
	 * Resolve for_each tool_input by replacing {{item}} and {{index}} placeholders
	 */
	private resolveForEachInput(
		toolInput: Record<string, unknown>,
		item: any,
		index: number
	): Record<string, unknown> {
		Logger.debug(`[Mastra] resolveForEachInput: START`, {
			index,
			itemType: typeof item,
			itemValue: typeof item === 'string' ? item : JSON.stringify(item).substring(0, 100),
			toolInputKeys: Object.keys(toolInput)
		});
		
		const resolved: Record<string, unknown> = {};
		
		for (const [key, value] of Object.entries(toolInput)) {
			Logger.debug(`[Mastra] resolveForEachInput: Processing key "${key}"`, {
				valueType: Array.isArray(value) ? 'array' : typeof value,
				valuePreview: typeof value === 'string' ? value : JSON.stringify(value).substring(0, 100)
			});
			if (typeof value === 'string') {
				// Check if the value is ONLY a template (e.g., "{{item.files}}" or "{{item}}")
				// In this case, return the actual value instead of stringifying it
				const itemFieldMatch = value.match(/^\{\{item\.([^}]+)\}\}$/);
				if (itemFieldMatch) {
					const field = itemFieldMatch[1];
					if (typeof item === 'object' && item !== null && field in item) {
						// Return the actual value (preserves arrays, objects, etc.)
						resolved[key] = item[field];
						continue;
					}
				}
				
				const itemMatch = value.match(/^\{\{item\}\}$/);
				if (itemMatch) {
					// Return the entire item as-is
					resolved[key] = item;
					continue;
				}
				
				// Otherwise, perform string replacement for templates embedded in strings
				let resolvedValue = value;
				
				// Replace {{index}}
				resolvedValue = resolvedValue.replace(/\{\{index\}\}/g, String(index));
				
				// Replace {{item.field}} patterns (embedded in string)
				resolvedValue = resolvedValue.replace(/\{\{item\.([^}]+)\}\}/g, (match, field) => {
					if (typeof item === 'object' && item !== null && field in item) {
						const fieldValue = item[field];
						return typeof fieldValue === 'string' ? fieldValue : JSON.stringify(fieldValue);
					}
					return match; // Keep original if field not found
				});
				
				// Replace {{item}} (embedded in string)
				if (resolvedValue.includes('{{item}}')) {
					if (typeof item === 'string') {
						resolvedValue = resolvedValue.replace(/\{\{item\}\}/g, item);
					} else {
						resolvedValue = resolvedValue.replace(/\{\{item\}\}/g, JSON.stringify(item));
					}
				}
				
				resolved[key] = resolvedValue;
			} else if (Array.isArray(value)) {
				// Recursively resolve templates in arrays
				resolved[key] = value.map(arrayItem => {
					if (typeof arrayItem === 'string') {
						// Check if array item is ONLY a template
						const itemFieldMatch = arrayItem.match(/^\{\{item\.([^}]+)\}\}$/);
						if (itemFieldMatch) {
							const field = itemFieldMatch[1];
							if (typeof item === 'object' && item !== null && field in item) {
								return item[field];
							}
						}
						
						const itemMatch = arrayItem.match(/^\{\{item\}\}$/);
						if (itemMatch) {
							return item;
						}
						
						// Perform string replacement for embedded templates
						let resolvedArrayItem = arrayItem;
						resolvedArrayItem = resolvedArrayItem.replace(/\{\{index\}\}/g, String(index));
						resolvedArrayItem = resolvedArrayItem.replace(/\{\{item\.([^}]+)\}\}/g, (match, field) => {
							if (typeof item === 'object' && item !== null && field in item) {
								const fieldValue = item[field];
								return typeof fieldValue === 'string' ? fieldValue : JSON.stringify(fieldValue);
							}
							return match;
						});
						if (resolvedArrayItem.includes('{{item}}')) {
							if (typeof item === 'string') {
								resolvedArrayItem = resolvedArrayItem.replace(/\{\{item\}\}/g, item);
							} else {
								resolvedArrayItem = resolvedArrayItem.replace(/\{\{item\}\}/g, JSON.stringify(item));
							}
						}
						return resolvedArrayItem;
					}
					return arrayItem;
				});
			} else if (typeof value === 'object' && value !== null) {
				// Recursively resolve templates in nested objects
				Logger.debug(`[Mastra] resolveForEachInput: Recursively resolving nested object for key "${key}"`);
				resolved[key] = this.resolveForEachInput(value as Record<string, unknown>, item, index);
			} else {
				resolved[key] = value;
				Logger.debug(`[Mastra] resolveForEachInput: Key "${key}" copied as-is`, {
					valueType: typeof value
				});
			}
		}
		
		Logger.debug(`[Mastra] resolveForEachInput: END`, {
			resolvedKeys: Object.keys(resolved),
			resolvedPreview: JSON.stringify(resolved).substring(0, 200)
		});
		
		return resolved;
	}
	
	/**
	 * Resolve template strings like {{step1.stories}} in input parameters
	 * Supports nested paths like {{step1.listing.files}}
	 * Supports array indexing like {{step1.results[0].url}}
	 * Also handles inline templates in strings like "Content: {{step2.title}}"
	 */
	private resolveTemplates(
		input: Record<string, unknown>, 
		stepOutputs: Map<string, any>,
		stepTools: Map<string, string>
	): Record<string, unknown> {
		const resolved = {} as Record<string, unknown>;
		
		for (const [key, value] of Object.entries(input)) {
			if (typeof value === 'string') {
				// Check if entire value is a template string - Direct access format: {{step1.stories}} or {{step1.results[0].url}}
				const fullTemplateMatch = value.match(/^\{\{(step\d+)(?:\.([.\w\[\]]+))?\}\}$/);
				if (fullTemplateMatch) {
					const [, stepId, outputPath] = fullTemplateMatch;
					const stepOutput = stepOutputs.get(stepId);
					
					if (stepOutput) {
						let resolvedValue;
						
						// If no path specified, return entire output
						if (!outputPath) {
							resolvedValue = stepOutput;
						} else {
							// Resolve path using dot notation
							resolvedValue = this.getNestedValue(stepOutput, outputPath);
						}
						
						if (resolvedValue !== undefined) {
							resolved[key] = resolvedValue;
							Logger.debug(`[MastraAgent] Resolved template {{${stepId}${outputPath ? '.' + outputPath : ''}}} for key "${key}"`);
						} else {
							Logger.warn(`[MastraAgent] Template {{${stepId}${outputPath ? '.' + outputPath : ''}}}: path not found in output`);
							resolved[key] = undefined;
						}
					} else {
						Logger.warn(`[MastraAgent] Cannot resolve template {{${stepId}${outputPath ? '.' + outputPath : ''}}}: step not found or not completed`);
						resolved[key] = undefined;
					}
				} else if (value.includes('{{')) {
					// Handle inline templates in strings like "Content: {{step2.stories}}" or "URL: {{step3.results[0].url}}"
					let resolvedString = value;
					const inlineMatches = value.matchAll(/\{\{(step\d+)(?:\.([.\w\[\]]+))?\}\}/g);
					
					for (const match of inlineMatches) {
						const [fullMatch, stepId, outputPath] = match;
						const stepOutput = stepOutputs.get(stepId);
						
						if (stepOutput) {
							let resolvedValue;
							
							// If no path specified, return entire output
							if (!outputPath) {
								resolvedValue = stepOutput;
							} else {
								// Resolve path using dot notation
								resolvedValue = this.getNestedValue(stepOutput, outputPath);
							}
							
							if (resolvedValue !== undefined) {
								// Convert to string for inline replacement
								const stringValue = typeof resolvedValue === 'string' ? resolvedValue : JSON.stringify(resolvedValue);
								resolvedString = resolvedString.replace(fullMatch, stringValue);
								Logger.debug(`[MastraAgent] Resolved inline template ${fullMatch} in key "${key}"`);
							} else {
								Logger.warn(`[MastraAgent] Inline template ${fullMatch}: path not found in output`);
								resolvedString = resolvedString.replace(fullMatch, '');
							}
						} else {
							Logger.warn(`[MastraAgent] Cannot resolve inline template ${fullMatch}: step not found`);
							resolvedString = resolvedString.replace(fullMatch, '');
						}
					}
					resolved[key] = resolvedString;
				} else {
					// Not a template, keep original value
					resolved[key] = value;
				}
			} else if (typeof value === 'object' && value !== null) {
				// Recursively resolve nested objects and arrays
				if (Array.isArray(value)) {
					resolved[key] = value.map(item => {
						if (typeof item === 'string') {
							// Resolve templates in array strings
							const fullTemplateMatch = item.match(/^\{\{(step\d+)(?:\.([\.\w\[\]]+))?\}\}$/);
							if (fullTemplateMatch) {
								const [, stepId, outputPath] = fullTemplateMatch;
								const stepOutput = stepOutputs.get(stepId);
								
								if (stepOutput) {
									const resolvedValue = outputPath 
										? this.getNestedValue(stepOutput, outputPath)
										: stepOutput;
									
									if (resolvedValue !== undefined) {
										Logger.debug(`[MastraAgent] Resolved array template {{${stepId}${outputPath ? '.' + outputPath : ''}}} in key "${key}"`);
										return resolvedValue;
									} else {
										Logger.warn(`[MastraAgent] Array template {{${stepId}${outputPath ? '.' + outputPath : ''}}}: path not found`);
										return undefined;
									}
								} else {
									Logger.warn(`[MastraAgent] Cannot resolve array template {{${stepId}${outputPath ? '.' + outputPath : ''}}}: step not found`);
									return undefined;
								}
							} else if (item.includes('{{')) {
								// Handle inline templates in array strings
								let resolvedString = item;
								const inlineMatches = item.matchAll(/\{\{(step\d+)(?:\.([\.\w\[\]]+))?\}\}/g);
								
								for (const match of inlineMatches) {
									const [fullMatch, stepId, outputPath] = match;
									const stepOutput = stepOutputs.get(stepId);
									
									if (stepOutput) {
										const resolvedValue = outputPath
											? this.getNestedValue(stepOutput, outputPath)
											: stepOutput;
										
										if (resolvedValue !== undefined) {
											const stringValue = typeof resolvedValue === 'string' ? resolvedValue : JSON.stringify(resolvedValue);
											resolvedString = resolvedString.replace(fullMatch, stringValue);
											Logger.debug(`[MastraAgent] Resolved inline array template ${fullMatch} in key "${key}"`);
										}
									}
								}
								return resolvedString;
							}
							return item;
						} else if (typeof item === 'object' && item !== null) {
							return this.resolveTemplates(item as Record<string, unknown>, stepOutputs, stepTools);
						}
						return item;
					});
				} else {
					resolved[key] = this.resolveTemplates(value as Record<string, unknown>, stepOutputs, stepTools);
				}
			} else {
				// Keep primitive values as-is
				resolved[key] = value;
			}
		}
		
		return resolved;
	}
	
	/**
	 * Get nested value from object using dot notation path and array indexing
	 * Examples:
	 * - getNestedValue({listing: {files: [...]}}, "listing.files") returns [...]
	 * - getNestedValue({results: [{url: "..."}]}, "results[0].url") returns "..."
	 */
	private getNestedValue(obj: any, path: string): any {
		// Split path into parts, handling both dots and brackets
		// e.g., "results[0].url" -> ["results", "0", "url"]
		const parts: string[] = [];
		let current = '';
		
		for (let i = 0; i < path.length; i++) {
			const char = path[i];
			
			if (char === '[') {
				// Push current part if not empty
				if (current) {
					parts.push(current);
					current = '';
				}
			} else if (char === ']') {
				// Push array index
				if (current) {
					parts.push(current);
					current = '';
				}
			} else if (char === '.') {
				// Push current part and start new one
				if (current) {
					parts.push(current);
					current = '';
				}
			} else {
				current += char;
			}
		}
		
		// Push the last part
		if (current) {
			parts.push(current);
		}
		
		// Navigate through the path
		let value = obj;
		for (let i = 0; i < parts.length; i++) {
			const part = parts[i];
			if (value === null || value === undefined) {
				return undefined;
			}
			
			// Backward compatibility: skip 'output' prefix if it's the first part and not in the object
			// This allows both {{step1.results}} and {{step1.output.results}} to work
			if (i === 0 && part === 'output' && !(part in value)) {
				continue;
			}

			// Check if part is a numeric index (for arrays)
			const index = parseInt(part, 10);
			if (!isNaN(index) && Array.isArray(value)) {
				value = value[index];
			} else if (typeof value === 'object' && part in value) {
				value = value[part];
			} else {
				return undefined;
			}
		}
		
		return value;
	}
	
	/**
	 * Normalize tool parameter names to handle LLM variations
	 * Maps commonly used parameter names to the actual tool parameter names
	 */
	private normalizeToolParameters(toolName: string, params: Record<string, unknown>): Record<string, unknown> {
		let normalized = { ...params };
		
		// YouTube transcript tool: video_id -> url
		if (toolName === 'get_youtube_transcript') {
			if ('video_id' in normalized && !('url' in normalized)) {
				normalized.url = normalized.video_id;
				delete normalized.video_id;
				Logger.debug(`[MastraAgent] Normalized parameter: video_id -> url for ${toolName}`);
			}
		}
		
		// Fix nested content structure for create tool
		// Sometimes resolveStepInput creates {content: {content, title, path}} instead of {content, title, path}
	if ((toolName === 'create' || toolName === 'create_file') && 'content' in normalized && typeof normalized.content === 'object' && normalized.content !== null) {
		const contentObj = normalized.content as Record<string, unknown>;
		// Check if content is nested (has content, title, path inside)
		if ('content' in contentObj && 'title' in contentObj) {
			Logger.debug(`[MastraAgent] Flattening nested content structure for ${toolName}`);
			normalized = { ...contentObj } as Record<string, unknown>;
		}
	}
		
		// DuckDuckGo search tools: keywords -> query
		if (toolName.startsWith('duckduckgo_')) {
			if ('keywords' in normalized && !('query' in normalized)) {
				normalized.query = normalized.keywords;
				delete normalized.keywords;
				Logger.debug(`[MastraAgent] Normalized parameter: keywords -> query for ${toolName}`);
			}
		}
		
		// Web search tool: keywords -> query
		if (toolName === 'web_search') {
			if ('keywords' in normalized && !('query' in normalized)) {
				normalized.query = normalized.keywords;
				delete normalized.keywords;
				Logger.debug(`[MastraAgent] Normalized parameter: keywords -> query for ${toolName}`);
			}
		}
		
		// Bing search: keywords -> query
		if (toolName === 'bing_search') {
			if ('keywords' in normalized && !('query' in normalized)) {
				normalized.query = normalized.keywords;
				delete normalized.keywords;
				Logger.debug(`[MastraAgent] Normalized parameter: keywords -> query for ${toolName}`);
			}
		}
		
		// Search notes: search_term/keywords -> query
		if (toolName === 'search_notes' || toolName === 'enhanced_search') {
			if ('search_term' in normalized && !('query' in normalized)) {
				normalized.query = normalized.search_term;
				delete normalized.search_term;
				Logger.debug(`[MastraAgent] Normalized parameter: search_term -> query for ${toolName}`);
			}
			if ('keywords' in normalized && !('query' in normalized)) {
				normalized.query = normalized.keywords;
				delete normalized.keywords;
				Logger.debug(`[MastraAgent] Normalized parameter: keywords -> query for ${toolName}`);
			}
		}
		
			// Create tool: ensure path parameter exists and normalize content -> file_text
	if (toolName === 'create' || toolName === 'create_file') {
		// Normalize content -> file_text (the tool expects file_text parameter)
		if ('content' in normalized && !('file_text' in normalized)) {
			normalized.file_text = normalized.content;
			delete normalized.content;
			Logger.debug(`[MastraAgent] Normalized parameter: content -> file_text for ${toolName}`);
		}
			
		// Now check if file_text is an object with nested content (common issue)
		// This handles cases where content was {content: "text"} from generate_content step
		if ('file_text' in normalized && typeof normalized.file_text === 'object' && normalized.file_text !== null) {
			const fileTextObj = normalized.file_text as Record<string, unknown>;
			
			// Check if it has a nested 'content' field
			if ('content' in fileTextObj && typeof fileTextObj.content === 'string') {
				normalized.file_text = fileTextObj.content;
				Logger.debug(`[MastraAgent] Extracted content from nested file_text object`);
			} else if ('content' in fileTextObj) {
				// Content exists but is not a string
				normalized.file_text = JSON.stringify(fileTextObj.content, null, 2);
				Logger.warn(`[MastraAgent] Nested content is not a string, stringified`);
			} else {
				// No content field, stringify the entire object
				normalized.file_text = JSON.stringify(fileTextObj, null, 2);
				Logger.warn(`[MastraAgent] file_text object has no content field, stringified`);
			}
		} else if ('file_text' in normalized && typeof normalized.file_text !== 'string') {
			// Ensure file_text is always a string (handle undefined, null, etc.)
			if (normalized.file_text === undefined || normalized.file_text === null) {
				Logger.error(`[MastraAgent] file_text is ${normalized.file_text} - this indicates template resolution failed`);
				throw new Error(`create tool requires file_text parameter, but it is ${normalized.file_text}. Check that previous step output is available.`);
			}
			normalized.file_text = String(normalized.file_text);
			Logger.warn(`[MastraAgent] Converted file_text to string`);
		}
		
		// CRITICAL: Verify file_text exists and is not undefined
		if (!('file_text' in normalized) || normalized.file_text === undefined) {
			Logger.error(`[MastraAgent] create tool missing required file_text parameter. Normalized params:`, normalized);
			throw new Error(`create tool requires file_text parameter. Check that the step input includes file_text or content, and that template references (like {{stepN.output.content}}) are correct.`);
		}
		
		// If title exists but no path, generate path from title
		if ('title' in normalized && !('path' in normalized)) {
			const title = String(normalized.title);
			// Sanitize title for use as filename
			const sanitizedTitle = title
				.replace(/[<>:"/\\|?*\x00-\x1F]/g, '') // Remove invalid chars
				.replace(/\s+/g, '-') // Replace spaces with hyphens
				.substring(0, 200); // Limit length
			normalized.path = `${sanitizedTitle}.md`;
			Logger.debug(`[MastraAgent] Generated path from title: ${normalized.path}`);
		}
		
		// Ensure path ends with .md
		if ('path' in normalized && typeof normalized.path === 'string' && !normalized.path.endsWith('.md')) {
			normalized.path = `${normalized.path}.md`;
		}
		
		// Remove title parameter as it's not needed by the tool
		if ('title' in normalized) {
			delete normalized.title;
		}
	}
	
	return normalized;
}
	
	/**
	 * Detect the language of the text (zh or en)
	 */
	private detectLanguage(text: string): 'zh' | 'en' {
		if (!text || text.trim().length === 0) {
			return 'en'; // Default to English
		}
		
		// Count Chinese characters
		const chineseChars = text.match(/[\u4e00-\u9fa5]/g);
		const totalChars = text.replace(/\s/g, '').length;
		
		if (chineseChars && totalChars > 0) {
			const chineseRatio = chineseChars.length / totalChars;
			// If more than 30% Chinese characters, consider it Chinese
			if (chineseRatio > 0.3) {
				return 'zh';
			}
		}
		
		return 'en';
	}
	
	/**
	 * Get system prompt for content generation in the appropriate language
	 */
	private getContentGenerationSystemPrompt(language: 'zh' | 'en'): string {
		if (language === 'zh') {
			return `‰Ω†ÊòØ‰∏Ä‰∏™‰∏ì‰∏öÁöÑÂÜÖÂÆπÂàÜÊûê‰∏éÁîüÊàêÂä©Êâã„ÄÇ‰Ω†ÁöÑ‰ªªÂä°ÊòØÂü∫‰∫éÊèê‰æõÁöÑÂ§öÊ∫ê‰ø°ÊÅØÔºåÁîüÊàê‰∏Ä‰ªΩÁªºÂêàÊÄß„ÄÅÊ∑±ÂÖ•ÁöÑÂàÜÊûêÊä•Âëä„ÄÇ

Ê†∏ÂøÉË¶ÅÊ±ÇÔºö
1. **ÁªºÂêàÂàÜÊûê** - Êï¥ÂêàÊâÄÊúâÊù•Ê∫êÁöÑ‰ø°ÊÅØÔºåÊèê‰æõÂÖ®Èù¢ÁöÑËßÜËßíÂíåÊ∑±ÂÖ•ÁöÑÊ¥ûÂØü
2. **ÂèôËø∞ÊÄßÂÜô‰Ωú** - ‰ΩøÁî®ËøûË¥ØÁöÑÊÆµËêΩËøõË°åÊ∑±ÂÖ•ÂàÜÊûêÔºåÈÅøÂÖçËøáÂ∫¶‰æùËµñÈ°πÁõÆÁ¨¶Âè∑ÂàóË°®
   - È°πÁõÆÁ¨¶Âè∑‰ªÖÁî®‰∫éÊ∏ÖÂçï„ÄÅÂàó‰∏æÊàñË°•ÂÖÖËØ¥Êòé
   - ‰∏ª‰ΩìÂÜÖÂÆπÂ∫îËØ•ÊòØÊµÅÁïÖÁöÑÂàÜÊûêÊÄßÊÆµËêΩÔºåÂ±ïÁé∞ÈÄªËæëÊé®ÁêÜÂíåÊ¥ûÂØü
3. **ËØ≠Ë®ÄÂåπÈÖç** - Ê†πÊçÆÁî®Êà∑Êü•ËØ¢ÁöÑ‰∏ªË¶ÅËØ≠Ë®ÄÊí∞ÂÜôÔºà‰∏≠ÊñáÊü•ËØ¢Áî®‰∏≠ÊñáÔºåËã±ÊñáÊü•ËØ¢Áî®Ëã±ÊñáÔºâ
4. **ÂèØËßÜÂåñÂ¢ûÂº∫** - ÈÄÇÂΩì‰ΩøÁî®Ë°®Ê†ºÂíåMermaidÂõæË°®Êù•ÂëàÁé∞Ôºö
   - Ë°®Ê†ºÔºöÂØπÊØîÊï∞ÊçÆ„ÄÅÂÖ≥ÈîÆÊåáÊ†á„ÄÅÊó∂Èó¥Á∫øÁ≠â
   - MermaidÊµÅÁ®ãÂõæ/ÂÖ≥Á≥ªÂõæÔºöÂ±ïÁ§∫ÊµÅÁ®ã„ÄÅÊû∂ÊûÑ„ÄÅÂõ†ÊûúÂÖ≥Á≥ªÁ≠â
5. **Áõ¥Êé•ËæìÂá∫** - ÁîüÊàêÁöÑÂÜÖÂÆπÂ∞ÜÁõ¥Êé•‰ΩøÁî®Ôºå‰∏çË¶ÅÂåÖÂê´"‰ª•‰∏ãÊòØ..."Á≠âÂÖÉËØÑËÆ∫

ËæìÂá∫Ê†ºÂºèÔºö
- MarkdownÊ†ºÂºèÔºåÁªìÊûÑÊ∏ÖÊô∞
- ‰ªéÊ†áÈ¢òÁõ¥Êé•ÂºÄÂßãÔºàÂ¶Ç"## ÂàÜÊûêÊä•Âëä"ËÄåÈùû"‰ª•‰∏ãÊòØÂàÜÊûêÔºö## ÂàÜÊûêÊä•Âëä"Ôºâ
- ÊÆµËêΩ‰∏∫‰∏ªÔºåÈÖçÂêàÈÄÇÂΩìÁöÑÊ†áÈ¢ò„ÄÅË°®Ê†º„ÄÅÂõæË°®
- ÂèØÁõ¥Êé•‰ΩøÁî®ÔºåÊó†ÈúÄ‰øÆÊîπ`;
		}
		
		return `You are a professional content analysis and generation assistant. Your task is to synthesize information from multiple sources and produce a comprehensive, in-depth analytical report.

CORE REQUIREMENTS:
1. **Comprehensive Analysis** - Integrate all source materials to provide complete perspectives and deep insights
2. **Narrative Writing** - Use coherent paragraphs for in-depth analysis, avoiding over-reliance on bullet points
   - Bullet points should only be used for checklists, enumerations, or supplementary notes
   - Main content should be flowing analytical paragraphs demonstrating logical reasoning and insights
3. **Language Matching** - Write in the primary language of the user's query (Chinese for Chinese queries, English for English queries)
4. **Visual Enhancement** - Appropriately use tables and Mermaid diagrams to present:
   - Tables: Comparative data, key metrics, timelines, etc.
   - Mermaid diagrams: Processes, architectures, relationships, etc.
5. **Direct Output** - Content will be used as-is; do NOT include meta-commentary like "Here is..."

OUTPUT FORMAT:
- Markdown format with clear structure
- Start directly with content (e.g., "## Analysis Report" not "Here is the analysis: ## Analysis Report")
- Paragraph-focused with appropriate headings, tables, and diagrams
- Ready to use without modifications`;
	}
	
	private async generateContentWithLLM(input: Record<string, unknown>, stepIndex: number, options: AgentExecuteOptions): Promise<string> {
		Logger.debug('[MastraAgent] Generating content with LLM, input:', input);
		
		if (!this.provider) {
			throw new Error('No provider initialized for content generation');
		}
		
		// Get the current plan to access previous steps
		const plan = this.getCurrentPlan();
		if (!plan) {
			throw new Error('No plan available for content generation');
		}
		
		// Collect content from previous step results
		const contentPieces: string[] = [];
		let totalContentSize = 0;
		
		for (let i = 0; i < stepIndex; i++) {
			const prevStep = plan.steps[i];
			if (prevStep.status === 'completed' && prevStep.toolCalls?.[0]?.response) {
				const response = prevStep.toolCalls[0].response;
				
				// Clean the response to extract only actual content, removing metadata
				const cleanedContent = this.extractCleanContent(response, prevStep.tool);
				
				if (cleanedContent && cleanedContent.trim()) {
					const piece = `[Step ${i + 1} - ${prevStep.tool}]\n${cleanedContent}`;
					contentPieces.push(piece);
					totalContentSize += piece.length;
				}
			}
		}
		
		Logger.debug(`[MastraAgent] Collected ${contentPieces.length} content pieces, total size: ${totalContentSize} chars`);
		
		// Extract task description from input
		const task = input.task || input.description || input.prompt || 'Generate content based on previous steps';
		const taskStr = typeof task === 'string' ? task : JSON.stringify(task);
		
		// Detect language from original user query
		const language = this.detectLanguage(this.originalUserQuery);
		Logger.debug(`[MastraAgent] Detected language: ${language} for query: "${this.originalUserQuery.substring(0, 50)}..."`);
		
		// Use ContentBatchProcessor to intelligently handle content
		const modelName = this.provider.getModelName();
		const batchProcessor = new ContentBatchProcessor(this.provider, modelName);
		
		Logger.debug('[MastraAgent] Using ContentBatchProcessor for intelligent content processing');
		
		try {
			// Process content with automatic batching if needed
			const result = await batchProcessor.processContent(
				contentPieces,
				taskStr,
				language,
				(batchIndex, content) => {
					// Progress callback - update streaming UI if available
					Logger.debug(`[MastraAgent] Batch ${batchIndex} processed`);
					
					// Update streaming indicator to show progress
					if (this.streamingManager) {
						// Calculate percentage if total batches is known (we don't have total here easily without passing it)
						// But we can show "Processing batch X..."
						const message = this.i18n ? 
							this.i18n.t('planExecute.processingBatch', { index: batchIndex }) || `Processing batch ${batchIndex}...` :
							`Processing batch ${batchIndex}...`;
							
						this.streamingManager.updateStreamingIndicator(message);
					}
				},
				true, // Enable parallel processing (default, recommended for speed)
				(chunk) => {
					if (this.onContentStreamCallback) {
						this.onContentStreamCallback(stepIndex, chunk);
					}
				},
				this.originalUserQuery, // Pass the original user query to maintain context of ultimate goal
				options.abortController?.signal // Pass abort signal for immediate stop
			);
			
			Logger.debug('[MastraAgent] Content generation completed, result length:', result.length);
			return result;
		} catch (error) {
			Logger.error('[MastraAgent] Content generation failed:', error);
			throw new Error(`Content generation failed: ${error instanceof Error ? error.message : String(error)}`);
		}
	}
	
	/**
	 * Get the current plan being executed
	 */
	private getCurrentPlan(): AgentPlan | null {
		// The plan is stored in the execution context
		// We'll need to pass it through or store it as an instance variable
		return this.currentPlan || null;
	}
	
	/**
	 * Extract clean content from tool response, removing metadata and process information
	 * This ensures the final generated content only contains actual data, not processing artifacts
	 * 
	 * ONLY extracts meaningful fields:
	 * - For fetch_web_content: title + content
	 * - For search results: title + body/content + (optionally) url
	 * All metadata (success, wordCount, duration, etc.) is stripped
	 */
	private extractCleanContent(response: any, toolName: string): string {
		// Handle string responses directly
		if (typeof response === 'string') {
			return this.cleanTextContent(response);
		}
		
		// Handle object responses based on tool type
		if (typeof response === 'object' && response !== null) {
			// For fetch_web_content - ONLY extract title and content
			if (toolName === 'fetch_web_content') {
				if (response.results && Array.isArray(response.results)) {
					const contents = response.results
						.filter((r: any) => r.success && r.content) // Only successful fetches with content
						.map((r: any) => {
							// ONLY title and content - ignore all metadata
							const title = r.title ? `## ${r.title}\n\n` : '';
							const content = r.content || '';
							return title + content;
						})
						.filter(c => c.trim()); // Remove empty results
					
					return contents.join('\n\n---\n\n');
				}
				// Fallback: if there's a summary, use that
				if (response.summary) {
					return this.cleanTextContent(response.summary);
				}
			}
			
			// For search tools - extract title + body/content + url (optional)
			if (toolName.includes('search') || toolName === 'duckduckgo_text_search' || 
			    toolName === 'duckduckgo_news_search' || toolName === 'web_search') {
				if (response.results && Array.isArray(response.results)) {
					const contents = response.results
						.map((r: any, idx: number) => {
							const title = r.title || r.name || `ÊêúÁ¥¢ÁªìÊûú ${idx + 1}`;
							const body = r.body || r.content || r.description || '';
							// Include URL if available (useful for citation)
							const url = r.url ? `\nÊù•Ê∫ê: ${r.url}` : '';
							return `### ${title}\n\n${body}${url}`;
						})
						.filter(c => c.trim());
					
					return contents.join('\n\n');
				}
				// Fallback to formattedSummary if available
				if (response.formattedSummary) {
					return this.cleanTextContent(response.formattedSummary);
				}
			}
			
			// For content field directly
			if (response.content) {
				return this.cleanTextContent(response.content);
			}
			
			// For data field
			if (response.data) {
				return typeof response.data === 'string' 
					? this.cleanTextContent(response.data)
					: JSON.stringify(response.data, null, 2);
			}
			
			// For other objects, filter out ALL metadata fields aggressively
			const cleaned = { ...response };
			const metadataFields = [
				// Status/success indicators
				'success', 'status', 'error', 'errors',
				// Counts and statistics
				'totalUrls', 'successCount', 'failureCount', 'totalWords', 'wordCount',
				'totalResults', 'resultsCount', 'count', 'total',
				// Size and performance metrics
				'contentLength', 'duration', 'extractionMethod', 'method',
				// Messages and summaries (if results array exists)
				'message', 'summary', 'formattedSummary',
				// Metadata object
				'metadata'
			];
			metadataFields.forEach(field => delete cleaned[field]);
			
			// If only results remain, format them nicely
			if (Object.keys(cleaned).length === 1 && cleaned.results) {
				return JSON.stringify(cleaned.results, null, 2);
			}
			
			return JSON.stringify(cleaned, null, 2);
		}
		
		// Fallback
		return String(response);
	}
	
	/**
	 * Clean text content by removing common metadata markers and process information
	 * Removes all processing artifacts like "ÊäìÂèñÊàêÂäü"„ÄÅ"ÂÜÖÂÆπÈïøÂ∫¶"„ÄÅ"ÂçïËØçÊï∞"„ÄÅ"ÊäìÂèñËÄóÊó∂" etc.
	 */
	private cleanTextContent(text: string): string {
		if (typeof text !== 'string') {
			return String(text || '');
		}
		
		return text
			// Remove metadata headers and brackets
			.replace(/„Äê.*?ÊëòË¶Å„Äë/g, '')
			.replace(/„Äê.*?ÁªìÊûú„Äë/g, '')
			.replace(/^#+\s*(Web Content Fetch Results|Fetch Results|ÊêúÁ¥¢ÁªìÊûú|ÊäìÂèñÁªìÊûú).*$/gm, '')
			
			// Remove success/failure status indicators
			.replace(/^[‚úÖ‚ùå*-]\s*\*\*?(Status|Áä∂ÊÄÅ|ÊäìÂèñÊàêÂäü|ÊàêÂäü|Â§±Ë¥•)\*\*?[:Ôºö].*$/gm, '')
			.replace(/^\*\*?(ÊäìÂèñÊàêÂäü|ÊäìÂèñÂ§±Ë¥•|ÊàêÂäü|Â§±Ë¥•)\*\*?[:Ôºö].*$/gm, '')
			
			// Remove statistics and metrics (Chinese and English)
			.replace(/^\*\*?(Total|ÊÄªËÆ°|ÊÄªÊï∞).*?\*\*?[:Ôºö].*$/gm, '')
			.replace(/^\*\*?(Success|Successful|ÊàêÂäüÊï∞|ÊàêÂäü).*?\*\*?[:Ôºö].*$/gm, '')
			.replace(/^\*\*?(Failed|Failure|Â§±Ë¥•Êï∞|Â§±Ë¥•).*?\*\*?[:Ôºö].*$/gm, '')
			.replace(/^\*\*?(Content Length|ÂÜÖÂÆπÈïøÂ∫¶).*?\*\*?[:Ôºö].*$/gm, '')
			.replace(/^\*\*?(Word Count|ÂçïËØçÊï∞|ËØçÊï∞).*?\*\*?[:Ôºö].*$/gm, '')
			.replace(/^\*\*?(Duration|ËÄóÊó∂|ÊäìÂèñËÄóÊó∂|Áî®Êó∂).*?\*\*?[:Ôºö].*$/gm, '')
			.replace(/^\*\*?(Method|ÊñπÊ≥ï|ÊèêÂèñÊñπÊ≥ï|ÊäìÂèñÊñπÊ≥ï).*?\*\*?[:Ôºö].*$/gm, '')
			
			// Remove bullet points with metadata
			.replace(/^[*-]\s+(Ê†áÈ¢ò|ÂÜÖÂÆπÈïøÂ∫¶|ÂçïËØçÊï∞|ÊäìÂèñËÄóÊó∂|ÊäìÂèñÊàêÂäü|ÊàêÂäü|Â§±Ë¥•|ÊñπÊ≥ï)[:Ôºö].*$/gm, '')
			
			// Remove numbered list items with metadata
			.replace(/^\d+\.\s+\*\*?(Ê†áÈ¢ò|ÂÜÖÂÆπÈïøÂ∫¶|ÂçïËØçÊï∞|ÊäìÂèñËÄóÊó∂|ÊäìÂèñÊàêÂäü|ÊàêÂäü|Â§±Ë¥•)\*\*?[:Ôºö].*$/gm, '')
			
			// Remove separator lines
			.replace(/^[-=*]{3,}$/gm, '')
			
			// Remove "## N. URL" headers from fetch results
			.replace(/^##\s+\d+\.\s+https?:\/\/.*$/gm, '')
			
			// Remove content preview/summary headers
			.replace(/^###?\s*(Content Preview|ÂÜÖÂÆπÈ¢ÑËßà).*$/gm, '')
			
			// Clean up multiple consecutive newlines
			.replace(/\n{3,}/g, '\n\n')
			.trim();
	}
	
	/**
	 * Set callback for content generation streaming
	 * @param callback Function to call with streaming content chunks
	 */
	public setContentStreamCallback(callback: ((stepIndex: number, chunk: string) => void) | null): void {
		this.onContentStreamCallback = callback;
	}
	
	// Agent Ê®°Âºè‰∏çÁîüÊàê final answer - Â∑≤Âà†Èô§ generateFinalAnswer ÊñπÊ≥ï
	// ÊâÄÊúâÊâßË°åÁªìÊûúÈÄöËøáÂ∑•ÂÖ∑ÊâßË°åËøáÁ®ãÁõ¥Êé•ÊòæÁ§∫ÔºåÊó†ÈúÄÈ¢ùÂ§ñÁîüÊàêÊÄªÁªìÊÄßÂõûÁ≠î
	
	/**
	 * Convert Mastra plan format to AgentPlan format
	 */
	private convertMastraPlanToAgentPlan(mastraPlan: any): AgentPlan {
		try {
			const steps = (mastraPlan.steps || []).map((step: any) => 
				this.convertMastraStepToAgentStep(step)
			);
			
			return {
				id: mastraPlan.id || `plan_${Date.now()}`,
				steps,
				estimatedTokens: mastraPlan.estimatedTokens || 0
			};
		} catch (error) {
			Logger.error('[MastraAgent] Failed to convert Mastra plan:', error);
			return {
				id: `plan_${Date.now()}`,
				steps: [],
				estimatedTokens: 0
			};
		}
	}
	
	/**
	 * Convert Mastra step format to AgentStep format
	 */
	private convertMastraStepToAgentStep(mastraStep: any): AgentStep {
		return {
			id: mastraStep.id || mastraStep.stepId || `step_${Date.now()}`,
			tool: mastraStep.tool || mastraStep.toolName || 'unknown',
			input: mastraStep.input || mastraStep.args || {},
			reason: mastraStep.reason || mastraStep.description || '',
			status: this.convertMastraStatus(mastraStep.status),
			result: mastraStep.result,
			error: mastraStep.error
		};
	}
	
	/**
	 * Convert Mastra status to AgentStep status
	 */
	private convertMastraStatus(mastraStatus: string | undefined): AgentStep['status'] {
		switch (mastraStatus) {
			case 'pending':
			case 'waiting':
				return 'pending';
			case 'executing':
			case 'running':
				return 'executing';
			case 'completed':
			case 'success':
				return 'completed';
			case 'failed':
			case 'error':
				return 'failed';
			case 'cancelled':
			case 'aborted':
				return 'cancelled';
			default:
				return 'pending';
		}
	}

	/**
	 * Initialize memory for the agent
	 */
	private async initializeMemory(config: MastraAgentConfig): Promise<void> {
		try {
			Logger.debug('[MastraAgent] Initializing memory...');
			
			// Create memory manager if not provided
			if (!this.memoryManager && config.memoryConfig) {
				try {
					this.memoryManager = new MemoryManager(this.plugin, config.memoryConfig);
					await this.memoryManager.initialize();
				} catch (managerError) {
					Logger.error('[MastraAgent] Failed to create/initialize memory manager:', managerError);
					Logger.warn('[MastraAgent] Continuing without memory support');
					return;
				}
			}
			
			if (!this.memoryManager) {
				Logger.warn('[MastraAgent] No memory manager available');
				return;
			}
			
			// Use provided thread/resource IDs or defaults
			const threadId = this.threadId || config.threadId || `thread-${Date.now()}`;
			const resourceId = this.resourceId || config.resourceId;
			
			// Create memory instance with retry logic
			try {
				this.memory = await this.memoryManager.createMemory(
					threadId,
					resourceId,
					config.memoryConfig
				);
				
				// CRITICAL: Create thread AFTER creating memory (memory creation sets up storage adapter)
				if (resourceId) {
					try {
						await this.memoryManager.createThreadSimple({ 
							resourceId, 
							threadId,
							title: config.name || `Thread ${threadId}`
						});
					} catch (threadError) {
						Logger.warn('[MastraAgent] Failed to create thread, continuing without thread context:', threadError);
					}
				}
			} catch (memoryError) {
				Logger.error('[MastraAgent] Failed to create memory instance:', memoryError);
				
			// Try one more time with minimal config (fallback)
			try {
				Logger.warn('[MastraAgent] Retrying memory creation with minimal config...');
				this.memory = await this.memoryManager.createMemory(
					threadId,
					resourceId,
					{
						enableWorkingMemory: false,
						enableConversationHistory: true,
						conversationHistoryLimit: 10,
						enableSemanticRecall: false,
					}
				);
				Logger.info('[MastraAgent] Memory created with minimal config (conversation history only)');
				
				// Also create thread after successful memory creation
				if (resourceId) {
					try {
						await this.memoryManager.createThreadSimple({ 
							resourceId, 
							threadId,
							title: config.name || `Thread ${threadId}`
						});
					} catch (threadError) {
						Logger.warn('[MastraAgent] Failed to create thread in fallback, continuing without thread context:', threadError);
					}
				}
			} catch (retryError) {
				Logger.error('[MastraAgent] Memory creation failed even with minimal config:', retryError);
				Logger.warn('[MastraAgent] Agent will run without memory support');
				return;
			}
		}			// Store IDs for future use
			this.threadId = threadId;
			this.resourceId = resourceId;
			
			// Add memory to agent config if agent supports it
			if (this.agent && typeof this.agent === 'object') {
				(this.agent as any).memory = this.memory;
			}
			
			Logger.debug('[MastraAgent] Memory initialized:', {
				threadId: this.threadId,
				resourceId: this.resourceId,
				hasMemory: !!this.memory
			});
		} catch (error) {
			Logger.error('[MastraAgent] Failed to initialize memory:', error);
			Logger.warn('[MastraAgent] Agent will continue without memory support');
			// Don't throw - memory is optional and agent should still work
		}
	}

	/**
	 * Update working memory with new information
	 * This allows the agent to persist important user information
	 */
	async updateWorkingMemory(content: string): Promise<void> {
		if (!this.memory || !this.memoryManager || !this.threadId) {
			Logger.warn('[MastraAgent] Memory not initialized, cannot update working memory');
			return;
		}

		try {
			await this.memoryManager.updateWorkingMemory(
				this.memory,
				this.threadId,
				this.resourceId || undefined,
				content
			);
			Logger.debug('[MastraAgent] Working memory updated');
		} catch (error) {
			Logger.error('[MastraAgent] Failed to update working memory:', error);
		}
	}

	/**
	 * Get working memory content
	 */
	async getWorkingMemory(): Promise<string | null> {
		if (!this.memory || !this.memoryManager || !this.threadId) {
			return null;
		}

		try {
			return await this.memoryManager.getWorkingMemory(
				this.memory,
				this.threadId,
				this.resourceId || undefined
			);
		} catch (error) {
			Logger.error('[MastraAgent] Failed to get working memory:', error);
			return null;
		}
	}

	/**
	 * Set thread ID for memory scoping
	 * Useful when switching between different conversation threads
	 */
	async setThreadId(threadId: string, createIfNotExists: boolean = true): Promise<void> {
		if (!this.memoryManager) {
			Logger.warn('[MastraAgent] Memory manager not available');
			return;
		}

		try {
			this.threadId = threadId;
			
			// Recreate memory instance with new thread ID
			if (this.memory) {
				this.memory = await this.memoryManager.createMemory(
					threadId,
					this.resourceId || undefined
				);
				
				// Update agent's memory reference
				if (this.agent && typeof this.agent === 'object') {
					(this.agent as any).memory = this.memory;
				}
			}
			
			Logger.debug('[MastraAgent] Thread ID updated:', threadId);
		} catch (error) {
			Logger.error('[MastraAgent] Failed to set thread ID:', error);
		}
	}

	/**
	 * Get current thread ID
	 */
	getThreadId(): string | null {
		return this.threadId;
	}

	/**
	 * Get current resource ID
	 */
	getResourceId(): string | null {
		return this.resourceId;
	}

	/**
	 * Get current memory configuration
	 */
	getMemoryConfig(): MemoryConfig | null {
		if (!this.memoryManager) {
			return null;
		}
		return this.memoryManager.getConfig();
	}

	/**
	 * Check if memory is enabled
	 */
	hasMemory(): boolean {
		return !!this.memory;
	}
	
	/**
	 * Set callback for sequential step error handling
	 * This allows the processor to show error action panel and wait for user decision
	 */
	setSequentialStepErrorHandler(
		handler: (step: AgentStep, stepIndex: number) => Promise<'skip' | 'retry' | 'regenerate'>
	): void {
		this.onSequentialStepError = handler;
	}
	
	/**
	 * Regenerate a failed step using LLM
	 * This method will ask the LLM to regenerate the step parameters based on the error
	 */
	private async regenerateStep(failedStep: AgentStep, stepIndex: number, plan: AgentPlan): Promise<AgentStep> {
		Logger.debug('[MastraAgent] Regenerating step:', failedStep.id);
		
		// Build context for regeneration
		const executedSteps = plan.steps.slice(0, stepIndex);
		const executionSummary = executedSteps
			.filter(s => s.status === 'completed')
			.map(step => ({
				id: step.id,
				tool: step.tool,
				result: step.result ? JSON.stringify(step.result).substring(0, 200) : null
			}));
		
		// Build regeneration prompt
		const regenerationPrompt = `A step in the execution plan has failed. Please regenerate this step with corrected parameters.

FAILED STEP:
- Tool: ${failedStep.tool}
- Parameters: ${JSON.stringify(failedStep.input)}
- Error: ${failedStep.error}
- Reason: ${failedStep.reason}

EXECUTION CONTEXT:
Previous successful steps:
${JSON.stringify(executionSummary, null, 2)}

ORIGINAL GOAL:
${this.originalUserQuery}

Please analyze the error and provide a CORRECTED version of this step with fixed parameters.
Respond with ONLY a JSON object in this format:
{
  "step_id": "${failedStep.id}",
  "tool": "tool_name",
  "input": {...corrected_parameters...},
  "reason": "explanation of what was fixed",
  "dependencies": ["step_id_if_any"]
}`;

		try {
			const response = await this.getLLMResponse(regenerationPrompt);
			const parsed = JSON.parse(response);
			
			const regeneratedStep: AgentStep = {
				id: parsed.step_id || failedStep.id,
				tool: parsed.tool || failedStep.tool,
				input: parsed.input || failedStep.input,
				reason: parsed.reason || 'Regenerated after failure',
				status: 'pending',
				dependencies: parsed.dependencies || failedStep.dependencies || []
			};
			
			Logger.debug('[MastraAgent] Step regenerated successfully:', regeneratedStep.tool);
			return regeneratedStep;
			
		} catch (error) {
			Logger.error('[MastraAgent] Failed to regenerate step:', error);
			// Return original step with status reset
			return {
				...failedStep,
				status: 'pending',
				error: undefined
			};
		}
	}

	/**
	 * Compact conversation messages before sending to LLM
	 * This is called when token count exceeds threshold
	 */
	protected async compactConversationMessages(
		messages: ChatMessage[],
		memorySettings: any
	): Promise<ChatMessage[]> {
		const preserveCount = memorySettings.compactionPreserveCount || 4;
		const targetTokens = memorySettings.compactionTarget || 4000;
		
		// Split messages into old (to compact) and recent (to preserve)
		const recentMessages = messages.slice(-preserveCount);
		const oldMessages = messages.slice(0, -preserveCount);
		
		if (oldMessages.length === 0) {
			Logger.debug('[MastraAgent] All messages are recent, no compaction possible');
			return messages.slice(-preserveCount); // Simple truncation
		}
		
		Logger.debug('[MastraAgent] Compacting', oldMessages.length, 'older messages, preserving', recentMessages.length, 'recent ones');
		
		try {
			// Generate summary of old messages
			const summary = await this.generateMessageSummary(oldMessages, memorySettings);
			
			// Create a system message with the summary
			const summaryMessage: ChatMessage = {
				id: `summary-${Date.now()}`,
				role: 'system',
				content: `[Conversation History Summary]\nThe following is a summary of earlier conversation history to save context space:\n\n${summary}\n\n[End of Summary - Recent messages follow]`,
				timestamp: Date.now()
			};
			
			// Combine summary with recent messages
			const compactedMessages = [summaryMessage, ...recentMessages];
			
			// Check if we achieved target
			const compactedTokens = TokenManager.estimateTokensForMessages(compactedMessages);
			Logger.debug('[MastraAgent] Compaction result:', {
				originalMessages: messages.length,
				compactedMessages: compactedMessages.length,
				compactedTokens,
				targetTokens
			});
			
			if (compactedTokens > targetTokens) {
				Logger.warn('[MastraAgent] Compacted size still exceeds target, may need more aggressive settings');
			}
			
			return compactedMessages;
		} catch (error) {
			Logger.error('[MastraAgent] Failed to generate summary:', error);
			// Fallback to simple truncation
			return messages.slice(-preserveCount);
		}
	}
	
	/**
	 * Generate a summary of messages using LLM
	 */
	protected async generateMessageSummary(
		messages: ChatMessage[],
		memorySettings: any
	): Promise<string> {
		const plugin = this.plugin;
		
		// Format messages for summarization
		const conversationText = messages
			.map(msg => {
				const role = msg.role === 'user' ? 'User' : 
							msg.role === 'assistant' ? 'Assistant' : 
							msg.role.charAt(0).toUpperCase() + msg.role.slice(1);
				
				let content = '';
				if (typeof msg.content === 'string') {
					content = msg.content;
				} else if (Array.isArray(msg.content)) {
					content = msg.content
						.map(part => part.type === 'text' ? part.text : `[${part.type}]`)
						.join(' ');
				}
				
				return `${role}: ${content}`;
			})
			.join('\n\n');
		
		// Get compaction model provider (use active provider if no specific compaction model set)
		const compactionProvider = plugin.getActiveProvider();
		
		if (!compactionProvider) {
			throw new Error('No active provider available for compaction');
		}
		
		const compactionPrompt = `You are an assistant that creates concise summaries of conversation history.

Your task is to:
1. Capture the key topics, questions, and insights discussed
2. Preserve important context that may be relevant for future messages
3. Preserve specific details: names, numbers, dates, technical terms, and user preferences
4. Target summary length: approximately 25% (one quarter) of the original conversation length
5. Do NOT compress too aggressively - maintain enough detail to preserve context
6. Use clear, structured formatting (bullet points or paragraphs as appropriate)
7. Focus on removing redundancy while keeping all meaningful information

Guidelines:
- Include user instructions, preferences, and any unresolved questions
- Maintain chronological flow where relevant for understanding
- Omit redundant pleasantries and filler content
- Keep enough detail to continue the conversation naturally

Summarize the following conversation history:`;
		
		// Use our provider's sendMessage method instead of AI SDK's generateText
		const compactionMessages: ChatMessage[] = [
			{
				id: Date.now().toString(),
				role: 'user',
				content: conversationText,
				timestamp: Date.now()
			}
		];
		
		const response = await compactionProvider.sendMessage(
			compactionMessages,
			undefined, // no tools
			compactionPrompt // system message
		);
		
		return response.content;
	}

	/**
	 * Helper to get a non-streaming response from the LLM
	 */
	private async getLLMResponse(prompt: string): Promise<string> {
		if (!this.provider) {
			throw new Error('No provider initialized');
		}

		const messages: ChatMessage[] = [
			{
				id: 'system-' + Date.now(),
				role: 'user',
				content: prompt,
				timestamp: Date.now()
			}
		];

		let fullText = '';
		await this.provider.sendStreamingMessage(messages, (chunk: any) => {
			if (chunk.delta) {
				fullText += chunk.delta;
			}
		});

		return fullText;
	}

	/**
	 * Clean up resources
	 */
	dispose(): void {
		Logger.debug('[MastraAgent] Disposing resources...');
		this.agent = null;
		this.streamAdapter = null;
		this.memory = null;
		this.onSequentialStepError = null;
		// Don't dispose memoryManager as it might be shared across agents
	}
}
